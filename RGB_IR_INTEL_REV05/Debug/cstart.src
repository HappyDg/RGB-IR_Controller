	; Module start
	.compiler_version	"TASKING VX-toolset for TriCore: C compiler v6.2r2 Build 18041957 SN 07918494"
	.compiler_invocation	"ctc -f cc15860a --dep-file=.cstart.o.d -c99 --fp-model=3cflnrSTz -D__CPU__=tc23x -D__CPU_TC23X__ --core=tc1.6.x --fp-model=+float -D__SWPLATFORM__ -DIFX_CFG_USE_COMPILER_DEFAULT_LINKER -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05 -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\APP\\inc -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05/SoftwarePlatform/Configuration -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05/SoftwarePlatform/Scu/Std/InitApi -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05/SoftwarePlatform/Stm/Std/InitApi -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05/SoftwarePlatform/illd_tc23x/src/ifx/TC23x -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05/SoftwarePlatform/illd_tc23x/src/ifx/TC23x/_Reg -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05/SoftwarePlatform/illd_tc23x/src/ifx/SrvSw -ID:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05/SoftwarePlatform/illd_common/ifx_cfg/include -g2 --make-target=cstart.o -t4 --language=-gcc,-volatile,+strings,-kanji --default-near-size=8 -O2 --default-a1-size=0 --default-a0-size=0 --source --align=0 --compact-max-size=200 --switch=auto --error-limit=42 -o cstart.src ..\\cstart.c"
	.compiler_name		"ctc"
	;source	'..\\cstart.c'

	
$TC16X
	
	.sdecl	'.text.cstart._endinit_clear',code,cluster('_endinit_clear')
	.sect	'.text.cstart._endinit_clear'
	.align	2
	
	.global	_endinit_clear

; ..\cstart.c	     1  /**************************************************************************
; ..\cstart.c	     2  **                                                                        *
; ..\cstart.c	     3  **  FILE        :  cstart.c                                               *
; ..\cstart.c	     4  **                                                                        *
; ..\cstart.c	     5  **  DESCRIPTION :                                                         *
; ..\cstart.c	     6  **      The system startup code initializes the processor's registers     *
; ..\cstart.c	     7  **      and the application C variables.                                  *
; ..\cstart.c	     8  **                                                                        *
; ..\cstart.c	     9  **  Copyright 1996-2018 TASKING BV                                        *
; ..\cstart.c	    10  **                                                                        *
; ..\cstart.c	    11  **************************************************************************/
; ..\cstart.c	    12  
; ..\cstart.c	    13  #include "cstart.h"                             /* include configuration */
; ..\cstart.c	    14  
; ..\cstart.c	    15  #include <stdlib.h>
; ..\cstart.c	    16  #include <stdbool.h>
; ..\cstart.c	    17  
; ..\cstart.c	    18  #ifdef __CPU__
; ..\cstart.c	    19  #include __SFRFILE__(__CPU__)
; ..\cstart.c	    20  #endif
; ..\cstart.c	    21  
; ..\cstart.c	    22  #pragma weak   exit
; ..\cstart.c	    23  #pragma extern _Exit
; ..\cstart.c	    24  #pragma profiling off                           /* prevent profiling information on cstart */
; ..\cstart.c	    25  #pragma tradeoff 4                              /* preset tradeoff level (for size) */
; ..\cstart.c	    26  #pragma runtime BCM                             /* disable runtime error checking for cstart */
; ..\cstart.c	    27  #pragma nomisrac                                /* disable MISRA-C checking */
; ..\cstart.c	    28  #pragma immediate_in_code                       /* no external ROM access before bus configuration */
; ..\cstart.c	    29  
; ..\cstart.c	    30  #if __USE_ARGC_ARGV
; ..\cstart.c	    31  #pragma noclear                                 /* bss clearing not before cinit */
; ..\cstart.c	    32  static char argcv[__ARGCV_BUFSIZE] __align(4);
; ..\cstart.c	    33  #pragma clear
; ..\cstart.c	    34  extern int _argcv( const char *, size_t );
; ..\cstart.c	    35  #endif
; ..\cstart.c	    36  
; ..\cstart.c	    37  /* linker definitions */
; ..\cstart.c	    38  extern __far void _lc_ue_ustack[];      /* user stack end */
; ..\cstart.c	    39  extern __far void _lc_ue_istack[];      /* interrupt stack end */
; ..\cstart.c	    40  extern __far void _lc_u_int_tab[];      /* interrupt table */
; ..\cstart.c	    41  extern __far void _lc_u_trap_tab[];     /* trap table */
; ..\cstart.c	    42  extern __far void _SMALL_DATA_[];       /* centre of A0 addressable area */
; ..\cstart.c	    43  extern __far void _LITERAL_DATA_[];     /* centre of A1 addressable area */
; ..\cstart.c	    44  extern __far void _A8_DATA_[];          /* centre of A8 addressable area */
; ..\cstart.c	    45  extern __far void _A9_DATA_[];          /* centre of A9 addressable area */
; ..\cstart.c	    46  
; ..\cstart.c	    47  /* external functions */
; ..\cstart.c	    48  #if __C_INIT
; ..\cstart.c	    49  extern void _c_init(void);              /* C initialization function */
; ..\cstart.c	    50  #endif
; ..\cstart.c	    51  #ifdef __CALL_INIT
; ..\cstart.c	    52  extern void _call_init(void);           /* call a user function before main() */
; ..\cstart.c	    53  #endif
; ..\cstart.c	    54  #ifdef _CALL_ENDINIT
; ..\cstart.c	    55  extern void _endinit(void);             /* call a user function with protection switched off */
; ..\cstart.c	    56  #endif
; ..\cstart.c	    57  
; ..\cstart.c	    58  /* local functions */
; ..\cstart.c	    59  static void __noinline__ __noreturn__ __jump__ __init_sp( void );
; ..\cstart.c	    60  static void __noinline__ __noreturn__ __jump__ _start( void );
; ..\cstart.c	    61  
; ..\cstart.c	    62  #if ( defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	    63  #if __XC800_INIT
; ..\cstart.c	    64  static void _xc800_init ( void );
; ..\cstart.c	    65  #endif
; ..\cstart.c	    66  #endif
; ..\cstart.c	    67  
; ..\cstart.c	    68  /* library references */
; ..\cstart.c	    69  #pragma extern main
; ..\cstart.c	    70  extern int main( int argc, char *argv[] );
; ..\cstart.c	    71  
; ..\cstart.c	    72  /* endinit types */
; ..\cstart.c	    73  typedef enum
; ..\cstart.c	    74  {
; ..\cstart.c	    75          _ENDINIT_DISABLE,
; ..\cstart.c	    76          _ENDINIT_ENABLE
; ..\cstart.c	    77  }       _endinit_t;
; ..\cstart.c	    78  
; ..\cstart.c	    79  
; ..\cstart.c	    80  /*
; ..\cstart.c	    81   *      inlining is required for endinit_set and safety_endinit_set,
; ..\cstart.c	    82   *      because the CSA list is not ready to support function calls.
; ..\cstart.c	    83   */
; ..\cstart.c	    84  #ifdef inline
; ..\cstart.c	    85  #undef inline
; ..\cstart.c	    86  #endif
; ..\cstart.c	    87  
; ..\cstart.c	    88  static void inline endinit_set(_endinit_t endinit_value);
; ..\cstart.c	    89  
; ..\cstart.c	    90  /* external interface to endinit_set */
; ..\cstart.c	    91  extern void _endinit_clear(void) { endinit_set(_ENDINIT_DISABLE); }
; Function _endinit_clear
.L6:
_endinit_clear:	.type	func

; ..\cstart.c	    92  extern void _endinit_set  (void) { endinit_set(_ENDINIT_ENABLE); }
; ..\cstart.c	    93  
; ..\cstart.c	    94  #if __PROF_ENABLE__
; ..\cstart.c	    95  extern void __prof_init( void );
; ..\cstart.c	    96  #endif
; ..\cstart.c	    97  
; ..\cstart.c	    98  #if __CLOCKS_PER_SEC_INIT
; ..\cstart.c	    99  static void setclockpersec( void );
; ..\cstart.c	   100  extern unsigned long long setfoschz( unsigned long long );
; ..\cstart.c	   101  #endif
; ..\cstart.c	   102  
; ..\cstart.c	   103  #ifdef __RM_INIT
; ..\cstart.c	   104  #if __RM_INIT
; ..\cstart.c	   105  #include <fenv.h>
; ..\cstart.c	   106  #endif
; ..\cstart.c	   107  #endif
; ..\cstart.c	   108  
; ..\cstart.c	   109  #if ( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	   110  #define WDT_CON0        SCU_WDTCPU0CON0
; ..\cstart.c	   111  #define WDT_CON1        SCU_WDTCPU0CON1
; ..\cstart.c	   112  
; ..\cstart.c	   113  static void inline safety_endinit_set(_endinit_t endinit_value);
; ..\cstart.c	   114  
; ..\cstart.c	   115  /* external interface to endinit_set */
; ..\cstart.c	   116  extern void _safety_endinit_clear(void) { safety_endinit_set(_ENDINIT_DISABLE); }
; ..\cstart.c	   117  extern void _safety_endinit_set  (void) { safety_endinit_set(_ENDINIT_ENABLE); }
; ..\cstart.c	   118  #endif
; ..\cstart.c	   119  
; ..\cstart.c	   120  /* Configure start TC1 ... TC5 */
; ..\cstart.c	   121  #if     __START_INIT_TC1
; ..\cstart.c	   122  #define __STADD_INIT_TC1        1       /* Initialize start address TC1 */
; ..\cstart.c	   123  #define __HALT_INIT_TC1         1       /* Initialize HALT state of TC1 */
; ..\cstart.c	   124  #define __HALT_VALUE_TC1        2       /* Reset HALT TC1 */
; ..\cstart.c	   125  #else
; ..\cstart.c	   126  #define __STADD_INIT_TC1        0
; ..\cstart.c	   127  #define __HALT_INIT_TC1         0
; ..\cstart.c	   128  #define __HALT_VALUE_TC1        0
; ..\cstart.c	   129  #endif
; ..\cstart.c	   130  #if     __START_INIT_TC2
; ..\cstart.c	   131  #define __STADD_INIT_TC2        1       /* Initialize start address TC2 */
; ..\cstart.c	   132  #define __HALT_INIT_TC2         1       /* Initialize HALT state of TC2 */
; ..\cstart.c	   133  #define __HALT_VALUE_TC2        2       /* Reset HALT TC2 */
; ..\cstart.c	   134  #else
; ..\cstart.c	   135  #define __STADD_INIT_TC2        0
; ..\cstart.c	   136  #define __HALT_INIT_TC2         0
; ..\cstart.c	   137  #define __HALT_VALUE_TC2        0
; ..\cstart.c	   138  #endif
; ..\cstart.c	   139  #if     __START_INIT_TC3
; ..\cstart.c	   140  #define __STADD_INIT_TC3        1       /* Initialize start address TC3 */
; ..\cstart.c	   141  #define __HALT_INIT_TC3         1       /* Initialize HALT state of TC3 */
; ..\cstart.c	   142  #define __HALT_VALUE_TC3        2       /* Reset HALT TC3 */
; ..\cstart.c	   143  #else
; ..\cstart.c	   144  #define __STADD_INIT_TC3        0
; ..\cstart.c	   145  #define __HALT_INIT_TC3         0
; ..\cstart.c	   146  #define __HALT_VALUE_TC3        0
; ..\cstart.c	   147  #endif
; ..\cstart.c	   148  #if     __START_INIT_TC4
; ..\cstart.c	   149  #define __STADD_INIT_TC4        1       /* Initialize start address TC4 */
; ..\cstart.c	   150  #define __HALT_INIT_TC4         1       /* Initialize HALT state of TC4 */
; ..\cstart.c	   151  #define __HALT_VALUE_TC4        2       /* Reset HALT TC4 */
; ..\cstart.c	   152  #else
; ..\cstart.c	   153  #define __STADD_INIT_TC4        0
; ..\cstart.c	   154  #define __HALT_INIT_TC4         0
; ..\cstart.c	   155  #define __HALT_VALUE_TC4        0
; ..\cstart.c	   156  #endif
; ..\cstart.c	   157  #if     __START_INIT_TC5
; ..\cstart.c	   158  #define __STADD_INIT_TC5        1       /* Initialize start address TC5 */
; ..\cstart.c	   159  #define __HALT_INIT_TC5         1       /* Initialize HALT state of TC5 */
; ..\cstart.c	   160  #define __HALT_VALUE_TC5        2       /* Reset HALT TC5 */
; ..\cstart.c	   161  #else
; ..\cstart.c	   162  #define __STADD_INIT_TC5        0
; ..\cstart.c	   163  #define __HALT_INIT_TC5         0
; ..\cstart.c	   164  #define __HALT_VALUE_TC5        0
; ..\cstart.c	   165  #endif
; ..\cstart.c	   166  
; ..\cstart.c	   167  #if ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   168  #define __CLR_BHALT             0;
; ..\cstart.c	   169  #endif
; ..\cstart.c	   170  
; ..\cstart.c	   171  #if ( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H)
; ..\cstart.c	   172  #if (__HALT_INIT_TC1 && (__HALT_VALUE_TC1 & 0x2)) || (__HALT_INIT_TC2 && (__HALT_VALUE_TC2 & 0x2)) || (__HALT_INIT_TC3 && (__HALT_VALUE_TC3 & 0x2)) || (__HALT_INIT_TC4 && (__HALT_VALUE_TC4 & 0x2)) || (__HALT_INIT_TC5 && (__HALT_VALUE_TC5 & 0x2))
; ..\cstart.c	   173  #if __C_INIT || __CLOCKS_PER_SEC_INIT || __PROF_ENABLE__ || _CALL_ENDINIT || (defined __CALL_INIT)
; ..\cstart.c	   174  /* c init semaphores */
; ..\cstart.c	   175  #if ( defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H)
; ..\cstart.c	   176  #define __AT_NOT_CACHED_MEMORY__        __at(0x70000000)
; ..\cstart.c	   177  #else
; ..\cstart.c	   178  #define __AT_NOT_CACHED_MEMORY__
; ..\cstart.c	   179  #endif
; ..\cstart.c	   180  #pragma noclear                                 /* bss clearing not before cinit */                          
; ..\cstart.c	   181  unsigned int volatile __far __align(4)  _tcx_end_c_init __AT_NOT_CACHED_MEMORY__;       /* _tcx_end_c_init := 1 << core_id */
; ..\cstart.c	   182  #pragma clear
; ..\cstart.c	   183  #endif
; ..\cstart.c	   184  #endif
; ..\cstart.c	   185  #endif
; ..\cstart.c	   186  
; ..\cstart.c	   187  /*********************************************************************************
; ..\cstart.c	   188   * reset vector
; ..\cstart.c	   189   *********************************************************************************/
; ..\cstart.c	   190  
; ..\cstart.c	   191  #pragma section code libc.reset
; ..\cstart.c	   192  #pragma optimize g
; ..\cstart.c	   193  void _START( void )
; ..\cstart.c	   194  {
; ..\cstart.c	   195          __init_sp();
; ..\cstart.c	   196  }
; ..\cstart.c	   197  #pragma optimize restore
; ..\cstart.c	   198  #pragma section code restore
; ..\cstart.c	   199  
; ..\cstart.c	   200  /*********************************************************************************
; ..\cstart.c	   201   * EBU boot configuration
; ..\cstart.c	   202   *********************************************************************************/
; ..\cstart.c	   203  #if defined EBU_BOOTCFG && defined __EBU_BOOTCFG_VALUE
; ..\cstart.c	   204  #if __EBU_BOOTCFG_INIT
; ..\cstart.c	   205  #pragma section farrom libc.ebu_bootcfg
; ..\cstart.c	   206  const int __far _EBU_BOOTCFG __protect__  = __EBU_BOOTCFG_VALUE; /* locate at RESET + EBU_ALIGN */
; ..\cstart.c	   207  #pragma section farrom restore
; ..\cstart.c	   208  #endif
; ..\cstart.c	   209  #endif
; ..\cstart.c	   210  
; ..\cstart.c	   211  /*********************************************************************************
; ..\cstart.c	   212   * initialize stackpointer
; ..\cstart.c	   213   *********************************************************************************/
; ..\cstart.c	   214  
; ..\cstart.c	   215  static void __noinline__ __noreturn__ __jump__ __init_sp( void )
; ..\cstart.c	   216  {
; ..\cstart.c	   217          /* The initialization of the stackpointer is done in a seperate function, 
; ..\cstart.c	   218             because it must be executed in a function which has no stack use.
; ..\cstart.c	   219             
; ..\cstart.c	   220             When a function uses a stack it will be updated at the start of the 
; ..\cstart.c	   221             function. In this function, however, the stackpointer has an irrelevant
; ..\cstart.c	   222             value at the start of the function. A starting value for the stackpointer
; ..\cstart.c	   223             is determined and written in this function. The update to the 
; ..\cstart.c	   224             stackpointer at the start of the function would therefore be undone.
; ..\cstart.c	   225           */
; ..\cstart.c	   226           
; ..\cstart.c	   227          /* 
; ..\cstart.c	   228           * CPU_TC.033 workaround:
; ..\cstart.c	   229           * The stack pointers are aligned to quad-word boundary to workaround these 
; ..\cstart.c	   230           * functional problems CPU_TC.033.
; ..\cstart.c	   231           * Also the C compiler workaround for the appropriate CPU function problem
; ..\cstart.c	   232           * need to be enabled with --silicon-bug=cpu-tc033, to align circular
; ..\cstart.c	   233           * buffers on a quad-word boundary and to size all stack frames to an integral 
; ..\cstart.c	   234           * number of quad-words.
; ..\cstart.c	   235           */
; ..\cstart.c	   236  #if      __CPU_TC033_INITIAL__
; ..\cstart.c	   237  # define STACK_ALIGN    0xfffffff0
; ..\cstart.c	   238  #else
; ..\cstart.c	   239  # define STACK_ALIGN    0xfffffff8
; ..\cstart.c	   240  #endif
; ..\cstart.c	   241  
; ..\cstart.c	   242          /* 
; ..\cstart.c	   243           * Load user stack pointer.
; ..\cstart.c	   244           * Disable this if not started from RESET vector. (E.g.
; ..\cstart.c	   245           * ROM monitors require to keep in control of vectors)
; ..\cstart.c	   246           */
; ..\cstart.c	   247  #if  __USP_INIT
; ..\cstart.c	   248          void * sp = (void *)((unsigned int)(_lc_ue_ustack) & STACK_ALIGN);
; ..\cstart.c	   249          
; ..\cstart.c	   250          __set_sp( sp );
; ..\cstart.c	   251  #endif
; ..\cstart.c	   252          _start();
; ..\cstart.c	   253  }
; ..\cstart.c	   254  
; ..\cstart.c	   255  static void inline reset_psw( void )
; ..\cstart.c	   256  {
; ..\cstart.c	   257          unsigned int    value = 0x980;  /* Reset value */
; ..\cstart.c	   258  
; ..\cstart.c	   259          value |= (__CDC & 0x7f);        /* PSW.CDC call depth counter */
; ..\cstart.c	   260  
; ..\cstart.c	   261  #if __USER_STACK
; ..\cstart.c	   262          value &= ~0x200;                /* clear PSW.IS */
; ..\cstart.c	   263  #else
; ..\cstart.c	   264          value |= 0x200;                 /* set PSW.IS */
; ..\cstart.c	   265  #endif
; ..\cstart.c	   266          __mtcr(PSW, value);
; ..\cstart.c	   267  }
; ..\cstart.c	   268  
; ..\cstart.c	   269  /*********************************************************************************
; ..\cstart.c	   270   * startup code
; ..\cstart.c	   271   *********************************************************************************/
; ..\cstart.c	   272  
; ..\cstart.c	   273  static void __noinline__ __noreturn__ __jump__ _start( void )
; ..\cstart.c	   274  {
; ..\cstart.c	   275  
; ..\cstart.c	   276  #if ( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H)
; ..\cstart.c	   277  #if __STADD_INIT_TC1
; ..\cstart.c	   278          /*
; ..\cstart.c	   279           * Set start address of TC1
; ..\cstart.c	   280           * Reset value is 0xAFFFC000
; ..\cstart.c	   281           */
; ..\cstart.c	   282          extern void __noinline__ __noreturn__ __jump__ _start_tc1( void );
; ..\cstart.c	   283          CPU1_PC.U = (unsigned int)_start_tc1;
; ..\cstart.c	   284  #endif
; ..\cstart.c	   285  #if __STADD_INIT_TC2 && !( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	   286          /*
; ..\cstart.c	   287           * Set start address of TC2
; ..\cstart.c	   288           * Reset value is 0xAFFFC000
; ..\cstart.c	   289           */
; ..\cstart.c	   290          extern void __noinline__ __noreturn__ __jump__ _start_tc2( void );
; ..\cstart.c	   291          CPU2_PC.U = (unsigned int)_start_tc2;
; ..\cstart.c	   292  #endif
; ..\cstart.c	   293  #if __STADD_INIT_TC3 && ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   294          /*
; ..\cstart.c	   295           * Set start address of TC3
; ..\cstart.c	   296           * Reset value is 0xAFFFC000
; ..\cstart.c	   297           */
; ..\cstart.c	   298          extern void __noinline__ __noreturn__ __jump__ _start_tc3( void );
; ..\cstart.c	   299          CPU3_PC.U = (unsigned int)_start_tc3;
; ..\cstart.c	   300  #endif
; ..\cstart.c	   301  #if __STADD_INIT_TC4 && ( defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   302          /*
; ..\cstart.c	   303           * Set start address of TC4
; ..\cstart.c	   304           * Reset value is 0xAFFFC000
; ..\cstart.c	   305           */
; ..\cstart.c	   306          extern void __noinline__ __noreturn__ __jump__ _start_tc4( void );
; ..\cstart.c	   307          CPU4_PC.U = (unsigned int)_start_tc4;
; ..\cstart.c	   308  #endif
; ..\cstart.c	   309  #if __STADD_INIT_TC5 && ( defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   310          /*
; ..\cstart.c	   311           * Set start address of TC5
; ..\cstart.c	   312           * Reset value is 0xAFFFC000
; ..\cstart.c	   313           */
; ..\cstart.c	   314          extern void __noinline__ __noreturn__ __jump__ _start_tc5( void );
; ..\cstart.c	   315          CPU5_PC.U = (unsigned int)_start_tc5;
; ..\cstart.c	   316  #endif
; ..\cstart.c	   317  
; ..\cstart.c	   318  #if (__HALT_INIT_TC1 && (__HALT_VALUE_TC1 & 0x2)) || (__HALT_INIT_TC2 && (__HALT_VALUE_TC2 & 0x2)) || (__HALT_INIT_TC3 && (__HALT_VALUE_TC3 & 0x2)) || (__HALT_INIT_TC4 && (__HALT_VALUE_TC4 & 0x2)) || (__HALT_INIT_TC5 && (__HALT_VALUE_TC5 & 0x2))
; ..\cstart.c	   319  #if __C_INIT || __CLOCKS_PER_SEC_INIT || __PROF_ENABLE__ || _CALL_ENDINIT || (defined __CALL_INIT)
; ..\cstart.c	   320          /*
; ..\cstart.c	   321           *      Clear end of c init semaphores for the cores that are released.
; ..\cstart.c	   322           */
; ..\cstart.c	   323  #if __HALT_INIT_TC1 && __HALT_VALUE_TC1==2
; ..\cstart.c	   324  #define __TC1_END_C_INIT_MASK   0
; ..\cstart.c	   325  #else
; ..\cstart.c	   326  #define __TC1_END_C_INIT_MASK   1<<1
; ..\cstart.c	   327  #endif
; ..\cstart.c	   328  #if __HALT_INIT_TC2 && !( defined _REGTC26X_H || defined _REGTC26XB_H ) && __HALT_VALUE_TC2==2
; ..\cstart.c	   329  #define __TC2_END_C_INIT_MASK   0
; ..\cstart.c	   330  #else
; ..\cstart.c	   331  #define __TC2_END_C_INIT_MASK   1<<2
; ..\cstart.c	   332  #endif
; ..\cstart.c	   333  #if __HALT_INIT_TC3 && ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H ) && __HALT_VALUE_TC3==2
; ..\cstart.c	   334  #define __TC3_END_C_INIT_MASK   0
; ..\cstart.c	   335  #else
; ..\cstart.c	   336  #define __TC3_END_C_INIT_MASK   1<<3
; ..\cstart.c	   337  #endif
; ..\cstart.c	   338  #if __HALT_INIT_TC4 && ( defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H ) && __HALT_VALUE_TC4==2
; ..\cstart.c	   339  #define __TC4_END_C_INIT_MASK   0
; ..\cstart.c	   340  #else
; ..\cstart.c	   341  #define __TC4_END_C_INIT_MASK   1<<4
; ..\cstart.c	   342  #endif
; ..\cstart.c	   343  #if __HALT_INIT_TC5 && ( defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H ) && __HALT_VALUE_TC5==2
; ..\cstart.c	   344  #define __TC5_END_C_INIT_MASK   0
; ..\cstart.c	   345  #else
; ..\cstart.c	   346  #define __TC5_END_C_INIT_MASK   1<<5
; ..\cstart.c	   347  #endif
; ..\cstart.c	   348          _tcx_end_c_init = __TC1_END_C_INIT_MASK|__TC2_END_C_INIT_MASK|__TC3_END_C_INIT_MASK|__TC4_END_C_INIT_MASK|__TC5_END_C_INIT_MASK;
; ..\cstart.c	   349  #endif
; ..\cstart.c	   350  #endif
; ..\cstart.c	   351          /*
; ..\cstart.c	   352           * A core can be released by resetting its halt state.
; ..\cstart.c	   353           * HALT: 0 R:running W:unchanged
; ..\cstart.c	   354           *       1 R:halted  W:unchanged
; ..\cstart.c	   355           *       2 R:n.a.    W:reset halt
; ..\cstart.c	   356           *       3 R:n.a.    W:set halt when debug enable
; ..\cstart.c	   357           */
; ..\cstart.c	   358  #if __HALT_INIT_TC1
; ..\cstart.c	   359  #if ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   360          CPU1_SYSCON.B.BHALT=__CLR_BHALT;
; ..\cstart.c	   361  #else
; ..\cstart.c	   362          CPU1_DBGSR.B.HALT=__HALT_VALUE_TC1;
; ..\cstart.c	   363  #endif
; ..\cstart.c	   364  #endif
; ..\cstart.c	   365  #if __HALT_INIT_TC2 && !( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	   366  #if ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   367          CPU2_SYSCON.B.BHALT=__CLR_BHALT;
; ..\cstart.c	   368  #else
; ..\cstart.c	   369          CPU2_DBGSR.B.HALT=__HALT_VALUE_TC2;
; ..\cstart.c	   370  #endif
; ..\cstart.c	   371  #endif
; ..\cstart.c	   372  #if __HALT_INIT_TC3 && ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   373          CPU3_SYSCON.B.BHALT=__CLR_BHALT;
; ..\cstart.c	   374  #endif
; ..\cstart.c	   375  #if __HALT_INIT_TC4 && ( defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   376          CPU4_SYSCON.B.BHALT=__CLR_BHALT;
; ..\cstart.c	   377  #endif
; ..\cstart.c	   378  #if __HALT_INIT_TC5 && ( defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   379          CPU5_SYSCON.B.BHALT=__CLR_BHALT;
; ..\cstart.c	   380  #endif
; ..\cstart.c	   381  #endif  
; ..\cstart.c	   382          
; ..\cstart.c	   383          /* Do a dsync before changing any of the csfr values, thus any previous
; ..\cstart.c	   384           * background state gets flushed first. Required for applications that jump
; ..\cstart.c	   385           * to the reset address.
; ..\cstart.c	   386           */
; ..\cstart.c	   387          __dsync();
; ..\cstart.c	   388          
; ..\cstart.c	   389          /* Set the PSW to its reset value in case of a warm start */
; ..\cstart.c	   390          reset_psw();
; ..\cstart.c	   391  
; ..\cstart.c	   392          /* Set the PCXS and PCXO to its reset value in case of a warm start */
; ..\cstart.c	   393          unsigned int pcxi = __mfcr(PCXI);
; ..\cstart.c	   394          pcxi &= 0xfff00000;
; ..\cstart.c	   395          __mtcr(PCXI, pcxi);
; ..\cstart.c	   396  
; ..\cstart.c	   397          /*
; ..\cstart.c	   398           * Initialize Compatibility Control Register
; ..\cstart.c	   399           *
; ..\cstart.c	   400           * Core is 1.3.1
; ..\cstart.c	   401           * bit 0 (COMPAT.PIE)
; ..\cstart.c	   402           *      Program Integrity Error Compatibility
; ..\cstart.c	   403           *      0B Errors handled by CPU.
; ..\cstart.c	   404           *      1B Errors flagged off-core. TriCore 1.3 backwards compatibility.
; ..\cstart.c	   405           * bit 1 (COMPAT.DIE)
; ..\cstart.c	   406           *      Data Integrity Error Compatibility
; ..\cstart.c	   407           *      0B Errors handled by CPU.
; ..\cstart.c	   408           *      1B Errors flagged off-core. TriCore 1.3 backwards compatibility.
; ..\cstart.c	   409           * bit 2 (COMPAT.BP)
; ..\cstart.c	   410           *      Branch Predictor Compatibility
; ..\cstart.c	   411           *      0B Bi-model branch prediction.
; ..\cstart.c	   412           *      1B Static branch prediction. TriCore 1.3 backwards compatibility.
; ..\cstart.c	   413           *
; ..\cstart.c	   414           * Core is 1.3.1, 1.6 or 1.6.x
; ..\cstart.c	   415           * bit 3 (COMPAT.RM)
; ..\cstart.c	   416           *      Rounding Mode Compatibility
; ..\cstart.c	   417           *      0B PSW.RM not restored by RET.
; ..\cstart.c	   418           *      1B PSW.RM restored by RET. TriCore 1.3 backwards compatibility.
; ..\cstart.c	   419           *
; ..\cstart.c	   420           * Core is 1.6 or 1.6.x
; ..\cstart.c	   421           * bit 4 (COMPAT.SP)
; ..\cstart.c	   422           *      SYSCON Safety Protection Mode Compatibility
; ..\cstart.c	   423           *      0B SYSCON[31:1] safety endinit protected.
; ..\cstart.c	   424           *      1B SYSCON[31:1] not safety endinit protected (TC1.3 behavior).
; ..\cstart.c	   425           */
; ..\cstart.c	   426  #ifndef __CORE_TC13__
; ..\cstart.c	   427  #ifdef __COMPAT
; ..\cstart.c	   428  #if __COMPAT != 0xf
; ..\cstart.c	   429  #ifdef __CORE_TC131__
; ..\cstart.c	   430  #define __COMPAT_MASK   ~0xf
; ..\cstart.c	   431  #else
; ..\cstart.c	   432  #define __COMPAT_MASK   ~0x18
; ..\cstart.c	   433  #endif
; ..\cstart.c	   434          __mtcr(COMPAT, (__COMPAT_MASK|__COMPAT));
; ..\cstart.c	   435  #endif
; ..\cstart.c	   436  #endif
; ..\cstart.c	   437  #endif
; ..\cstart.c	   438          
; ..\cstart.c	   439  #if (  defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H)
; ..\cstart.c	   440          /*
; ..\cstart.c	   441           * Clear the ENDINIT bit in the WDTSCON0 register in order
; ..\cstart.c	   442           * to disable the write-protection for safety-critical registers
; ..\cstart.c	   443           * protected via the safety EndInit feature.
; ..\cstart.c	   444           */
; ..\cstart.c	   445          safety_endinit_set(_ENDINIT_DISABLE);
; ..\cstart.c	   446          
; ..\cstart.c	   447          /*
; ..\cstart.c	   448           * Disable the safety watchdog if requested. Safety watchdog
; ..\cstart.c	   449           * is enabled by default. The safety watchdog is disabled after
; ..\cstart.c	   450           * ENDINIT is set by safety_endinit_set().
; ..\cstart.c	   451           */       
; ..\cstart.c	   452  #if __SAFETY_WATCHDOG_DISABLE
; ..\cstart.c	   453          SCU_WDTSCON1.U |= 0x8;
; ..\cstart.c	   454          safety_endinit_set(_ENDINIT_ENABLE);
; ..\cstart.c	   455          safety_endinit_set(_ENDINIT_DISABLE);
; ..\cstart.c	   456  #endif
; ..\cstart.c	   457          
; ..\cstart.c	   458  #endif
; ..\cstart.c	   459          
; ..\cstart.c	   460          /*
; ..\cstart.c	   461           * Clear the ENDINIT bit in the WDT_CON0 register in order
; ..\cstart.c	   462           * to disable the write-protection for registers protected 
; ..\cstart.c	   463           * via the EndInit feature (for example: WDT_CON1).
; ..\cstart.c	   464           */
; ..\cstart.c	   465          endinit_set(_ENDINIT_DISABLE);
; ..\cstart.c	   466          
; ..\cstart.c	   467          /*
; ..\cstart.c	   468           * Disable the Watchdog if requested. Watchdog is enabled by default.
; ..\cstart.c	   469           * The Watchdog is disabled after ENDINIT is set by endinit_set().
; ..\cstart.c	   470           */       
; ..\cstart.c	   471  #if __WATCHDOG_DISABLE
; ..\cstart.c	   472          WDT_CON1.U |= 0x8;
; ..\cstart.c	   473          endinit_set(_ENDINIT_ENABLE);
; ..\cstart.c	   474          endinit_set(_ENDINIT_DISABLE);
; ..\cstart.c	   475  #endif
; ..\cstart.c	   476  
; ..\cstart.c	   477          /*
; ..\cstart.c	   478           * PMI_TC.003 workaround:
; ..\cstart.c	   479           * The TLB-A and TLB-B mappings are set to a page size of 16KB.
; ..\cstart.c	   480           */
; ..\cstart.c	   481  #if __PMI_TC003_INITIAL__  && defined MMU_CON
; ..\cstart.c	   482          unsigned int mmu_con = __mfcr(MMU_CON);
; ..\cstart.c	   483          mmu_con &= 0xffffffe1;      /* clear SZA and SZB */
; ..\cstart.c	   484          mmu_con |= 0x00000014;      /* set SZA=SZB=16k   */       
; ..\cstart.c	   485          __mtcr(MMU_CON, mmu_con);
; ..\cstart.c	   486  #endif
; ..\cstart.c	   487  
; ..\cstart.c	   488          /*
; ..\cstart.c	   489           * Load Base Address of Trap Vector Table.
; ..\cstart.c	   490           * Disable this if not started from RESET vector. (E.g.
; ..\cstart.c	   491           * ROM monitors require to keep in control of vectors)
; ..\cstart.c	   492           */
; ..\cstart.c	   493  #if __BTV_INIT
; ..\cstart.c	   494          __mtcr(BTV,  (unsigned int)_lc_u_trap_tab);
; ..\cstart.c	   495  #endif
; ..\cstart.c	   496  
; ..\cstart.c	   497          /*
; ..\cstart.c	   498           * Load Base Address of Interrupt Vector Table.
; ..\cstart.c	   499           * Disable this if not started from RESET vector. (E.g.
; ..\cstart.c	   500           * ROM monitors require to keep in control of vectors)
; ..\cstart.c	   501           */
; ..\cstart.c	   502  #if __BIV_INIT
; ..\cstart.c	   503  #if __BIV_SINGLE_INIT && (defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H)
; ..\cstart.c	   504          /*
; ..\cstart.c	   505           * Single Entry Vector Table for core tc1.6.1 or tc1.6.2 is supported
; ..\cstart.c	   506           * by _sevt_isr_tc0() calling interrupt handlers installed
; ..\cstart.c	   507           * with _sevt_isr_install() stored in _sevt_isrs_tc0 list.
; ..\cstart.c	   508           * The _sevt_isr_tc0() is located at interrupt vector table
; ..\cstart.c	   509           * entry 64. The start address of the interrupt vector table
; ..\cstart.c	   510           * is defined by linker definition INTTAB0, default value
; ..\cstart.c	   511           *_lc_u_int_tab is 0xa00f0000+0x800.
; ..\cstart.c	   512           */
; ..\cstart.c	   513  #pragma extern _sevt_isr_tc0
; ..\cstart.c	   514          __mtcr(BIV, (unsigned int)(_lc_u_int_tab) | (0xff<<3) | 1 );
; ..\cstart.c	   515  #else
; ..\cstart.c	   516  #if __BIV_8BYTE_INIT && (defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H)
; ..\cstart.c	   517          __mtcr(BIV, (unsigned int)(_lc_u_int_tab) | 1 );        /* 8 Byte vector spacing */
; ..\cstart.c	   518  #else
; ..\cstart.c	   519          __mtcr(BIV, (unsigned int)(_lc_u_int_tab));             /* 32 Byte vector spacing */
; ..\cstart.c	   520  #endif
; ..\cstart.c	   521  #endif
; ..\cstart.c	   522  #endif
; ..\cstart.c	   523  
; ..\cstart.c	   524          /*
; ..\cstart.c	   525           * Load interrupt stack pointer.
; ..\cstart.c	   526           * Disable this if not started from RESET vector. (E.g.
; ..\cstart.c	   527           * ROM monitors require to keep in control of vectors)
; ..\cstart.c	   528           */
; ..\cstart.c	   529  #if __ISP_INIT
; ..\cstart.c	   530          unsigned int isp = (unsigned int)(_lc_ue_istack) & STACK_ALIGN;
; ..\cstart.c	   531          __mtcr(ISP, isp);
; ..\cstart.c	   532  #endif
; ..\cstart.c	   533                                                            
; ..\cstart.c	   534          /*
; ..\cstart.c	   535           * PMU/PMI configuration.
; ..\cstart.c	   536           */
; ..\cstart.c	   537  #if defined PMI_CON0 && defined __PMI_CON0_VALUE
; ..\cstart.c	   538          if(__PMI_CON0_INIT)  PMI_CON0.U = __PMI_CON0_VALUE;        
; ..\cstart.c	   539  #endif
; ..\cstart.c	   540  #if defined PMI_CON1 && defined __PMI_CON1_VALUE
; ..\cstart.c	   541          if(__PMI_CON1_INIT)  PMI_CON1.U = __PMI_CON1_VALUE;        
; ..\cstart.c	   542  #endif  
; ..\cstart.c	   543  #if     defined PMI_CON2 && defined __PMI_CON2_VALUE && \ 
; ..\cstart.c	   544          (  defined _REGTC1337_H || defined _REGTC1367_H || defined _REGTC1387_H || defined _REGTC1728_H \ 
; ..\cstart.c	   545          || defined _REGTC1746_H || defined _REGTC1747_H || defined _REGTC1768_H || defined _REGTC1782_H \ 
; ..\cstart.c	   546          || defined _REGTC1784_H || defined _REGTC1184_H || defined _REGTC1797_H || defined _REGTC1197_H \ 
; ..\cstart.c	   547          || defined _REGTC1767_H || defined _REGTC1736_H \ 
; ..\cstart.c	   548          || defined _REGTC1738_H || defined _REGTC1167_H || defined _REGTC1724_H )
; ..\cstart.c	   549          if(__PMI_CON2_INIT)  PMI_CON2.U = __PMI_CON2_VALUE;        
; ..\cstart.c	   550  #endif
; ..\cstart.c	   551          
; ..\cstart.c	   552  #if defined PMU_EIFCON && defined __PMU_EIFCON_VALUE
; ..\cstart.c	   553          if(__PMU_EIFCON_INIT)  PMU_EIFCON.U = __PMU_EIFCON_VALUE;
; ..\cstart.c	   554  #endif
; ..\cstart.c	   555  
; ..\cstart.c	   556          /*
; ..\cstart.c	   557           * DMI configuration.
; ..\cstart.c	   558           */
; ..\cstart.c	   559  #if     defined DMI_CON && defined __DMI_CON_VALUE && \ 
; ..\cstart.c	   560          (  defined _REGTC1167_H || defined _REGTC1197_H || defined _REGTC1337_H || defined _REGTC1367_H \ 
; ..\cstart.c	   561          || defined _REGTC1387_H || defined _REGTC1728_H || defined _REGTC1738_H \ 
; ..\cstart.c	   562          || defined _REGTC1746_H || defined _REGTC1747_H || defined _REGTC1767_H || defined _REGTC1768_H \ 
; ..\cstart.c	   563          || defined _REGTC1782_H || defined _REGTC1784_H || defined _REGTC1184_H || defined _REGTC1797_H \ 
; ..\cstart.c	   564          || defined _REGTC1724_H )
; ..\cstart.c	   565          if(__DMI_CON_INIT)  DMI_CON.U = __DMI_CON_VALUE;        
; ..\cstart.c	   566  #endif
; ..\cstart.c	   567          
; ..\cstart.c	   568          /*
; ..\cstart.c	   569           * Data cache control (Reset 0H).
; ..\cstart.c	   570           * CPU_TC013 workaround:
; ..\cstart.c	   571           * The 16KB D-Cache is enabled to workaround
; ..\cstart.c	   572           * the CPU_TC013 functional problem.     
; ..\cstart.c	   573           * NOTE: Setting the D-Cache size must be done at the
; ..\cstart.c	   574           *       very beginning of the startup code.
; ..\cstart.c	   575           */
; ..\cstart.c	   576  #if defined  DMU_CON
; ..\cstart.c	   577  #  if __CPU_TC013_INITIAL__ 
; ..\cstart.c	   578          DMU_CON.U = 0x1;
; ..\cstart.c	   579  #  endif
; ..\cstart.c	   580  #endif
; ..\cstart.c	   581  
; ..\cstart.c	   582          /*
; ..\cstart.c	   583           * PCON0 configuration.
; ..\cstart.c	   584           */
; ..\cstart.c	   585  #if     defined PCON0 && defined __PCON0_VALUE
; ..\cstart.c	   586          if(__PCON0_INIT) __mtcr(PCON0, __PCON0_VALUE);
; ..\cstart.c	   587  #endif
; ..\cstart.c	   588  
; ..\cstart.c	   589          /*
; ..\cstart.c	   590           * DCON0 configuration.
; ..\cstart.c	   591           */
; ..\cstart.c	   592  #if     defined DCON0 && defined __DCON0_VALUE
; ..\cstart.c	   593          if(__DCON0_INIT) __mtcr(DCON0, __DCON0_VALUE);
; ..\cstart.c	   594  #endif
; ..\cstart.c	   595  
; ..\cstart.c	   596          /*
; ..\cstart.c	   597           *      TC29x requires configuration of Pad Driver Mode to support EBU
; ..\cstart.c	   598           */
; ..\cstart.c	   599  #if defined P24_PDR0 && defined __P24_PDR0_VALUE
; ..\cstart.c	   600          if(__P24_PDR0_INIT)  P24_PDR0.U = __P24_PDR0_VALUE;
; ..\cstart.c	   601  #endif
; ..\cstart.c	   602  #if defined P24_PDR1 && defined __P24_PDR1_VALUE
; ..\cstart.c	   603          if(__P24_PDR1_INIT)  P24_PDR1.U = __P24_PDR1_VALUE;
; ..\cstart.c	   604  #endif
; ..\cstart.c	   605  #if defined P25_PDR0 && defined __P25_PDR0_VALUE
; ..\cstart.c	   606          if(__P25_PDR0_INIT)  P25_PDR0.U = __P25_PDR0_VALUE;
; ..\cstart.c	   607  #endif
; ..\cstart.c	   608  #if defined P25_PDR1 && defined __P25_PDR1_VALUE
; ..\cstart.c	   609          if(__P25_PDR1_INIT)  P25_PDR1.U = __P25_PDR1_VALUE;
; ..\cstart.c	   610  #endif
; ..\cstart.c	   611  #if defined P30_PDR0 && defined __P30_PDR0_VALUE
; ..\cstart.c	   612          if(__P30_PDR0_INIT)  P30_PDR0.U = __P30_PDR0_VALUE;
; ..\cstart.c	   613  #endif
; ..\cstart.c	   614  #if defined P30_PDR1 && defined __P30_PDR1_VALUE
; ..\cstart.c	   615          if(__P30_PDR1_INIT)  P30_PDR1.U = __P30_PDR1_VALUE;
; ..\cstart.c	   616  #endif
; ..\cstart.c	   617  #if defined P31_PDR0 && defined __P31_PDR0_VALUE
; ..\cstart.c	   618          if(__P31_PDR0_INIT)  P31_PDR0.U = __P31_PDR0_VALUE;
; ..\cstart.c	   619  #endif
; ..\cstart.c	   620  #if defined P31_PDR1 && defined __P31_PDR1_VALUE
; ..\cstart.c	   621          if(__P31_PDR1_INIT)  P31_PDR1.U = __P31_PDR1_VALUE;
; ..\cstart.c	   622  #endif
; ..\cstart.c	   623          
; ..\cstart.c	   624          /*
; ..\cstart.c	   625           * Bus configuration EBU_CLC within endinit.
; ..\cstart.c	   626           */
; ..\cstart.c	   627  #  if defined EBU_CLC && defined __EBU_CLC_VALUE
; ..\cstart.c	   628          if(__EBU_CLC_INIT)  EBU_CLC.U = __EBU_CLC_VALUE;
; ..\cstart.c	   629  #  endif
; ..\cstart.c	   630  
; ..\cstart.c	   631          /*
; ..\cstart.c	   632           *      Setting up the PLL after Reset.
; ..\cstart.c	   633           *
; ..\cstart.c	   634           *      After reset, the system clock will be running at the VCO
; ..\cstart.c	   635           *      base frequency divided by a factor KDIV. To set up the PLL
; ..\cstart.c	   636           *      after reset, next action must be executed.
; ..\cstart.c	   637           */
; ..\cstart.c	   638  #if defined PLL_CLC && defined __PLL_CLC_VALUE
; ..\cstart.c	   639  #if     __PLL_CLC_INIT
; ..\cstart.c	   640  #define __PLL_CLC_SYSFS_VALUE   ((__PLL_CLC_VALUE>>2)&0x1)
; ..\cstart.c	   641  #define __PLL_CLC_VCOBYP_VALUE  ((__PLL_CLC_VALUE>>5)&0x1)
; ..\cstart.c	   642  #define __PLL_CLC_VCOSEL_VALUE  ((__PLL_CLC_VALUE>>6)&0x3)
; ..\cstart.c	   643  #define __PLL_CLC_KDIV_VALUE    ((__PLL_CLC_VALUE>>8)&0xf)
; ..\cstart.c	   644  #define __PLL_CLC_PDIV_VALUE    ((__PLL_CLC_VALUE>>13)&0x3)
; ..\cstart.c	   645  #define __PLL_CLC_NDIV_VALUE    ((__PLL_CLC_VALUE>>16)&0x7f)
; ..\cstart.c	   646          if ( PLL_CLC.B.BYPPIN == 0 )
; ..\cstart.c	   647          {
; ..\cstart.c	   648  #if     ( defined _REGTC1130_H )
; ..\cstart.c	   649                  while (OSC_CON.B.OSCR==1);                      /* Wait until the oscillator is running */
; ..\cstart.c	   650  #else
; ..\cstart.c	   651                  while (OSC_CON.B.OSCR==0);                      /* Wait until the oscillator is running */
; ..\cstart.c	   652  #endif
; ..\cstart.c	   653                  PLL_CLC.B.VCOBYP = 1;                           /* Enabled the VCO Bypass Mode */
; ..\cstart.c	   654                  PLL_CLC.B.VCOSEL = __PLL_CLC_VCOSEL_VALUE;      /* Select the VCO band */
; ..\cstart.c	   655                  PLL_CLC.B.PDIV = __PLL_CLC_PDIV_VALUE;
; ..\cstart.c	   656                  PLL_CLC.B.KDIV = __PLL_CLC_KDIV_VALUE;
; ..\cstart.c	   657                  PLL_CLC.B.NDIV = __PLL_CLC_NDIV_VALUE;
; ..\cstart.c	   658  #if __PLL_CLC_VCOBYP_VALUE==0
; ..\cstart.c	   659                  PLL_CLC.B.OSCDISC = 0;                          /* Connect the oscillator to the PLL */
; ..\cstart.c	   660                  while( PLL_CLC.B.LOCK==0);                      /* Wait until the PLL becomes locked */
; ..\cstart.c	   661                  PLL_CLC.B.VCOBYP = 0;                           /* Disabled the VCO Bypass Mode */
; ..\cstart.c	   662  #endif
; ..\cstart.c	   663          }
; ..\cstart.c	   664  #if     ( defined _REGTC1130_H )
; ..\cstart.c	   665          PLL_CLC.B.SYSFSL = __PLL_CLC_SYSFS_VALUE;                /* System frequency select */
; ..\cstart.c	   666  #else
; ..\cstart.c	   667  #if     (  defined _REGTC1762_H || defined _REGTC1764_H || defined _REGTC1766B_H \ 
; ..\cstart.c	   668          || defined _REGTC1164_H || defined _REGTC1166_H )
; ..\cstart.c	   669          PLL_CLC.B.RSV = __PLL_CLC_SYSFS_VALUE;                  /* System frequency select */
; ..\cstart.c	   670  #else
; ..\cstart.c	   671          PLL_CLC.B.SYSFS = __PLL_CLC_SYSFS_VALUE;                /* System frequency select */
; ..\cstart.c	   672  #endif
; ..\cstart.c	   673  #endif
; ..\cstart.c	   674  #endif
; ..\cstart.c	   675  #endif
; ..\cstart.c	   676  
; ..\cstart.c	   677           /*
; ..\cstart.c	   678            * Configure CCU Clock Control
; ..\cstart.c	   679            *
; ..\cstart.c	   680            * For AURIX derivatives it is required to set the update request only
; ..\cstart.c	   681            * in the last CCUCON that is initialized. Set CCUCONx.UP where x is
; ..\cstart.c	   682            * the last one. A new complete parameter set is transferred to
; ..\cstart.c	   683            * the CCU.
; ..\cstart.c	   684            */
; ..\cstart.c	   685  #if defined SCU_CCUCON0 && defined __SCU_CCUCON0_VALUE
; ..\cstart.c	   686           if(__SCU_CCUCON0_INIT)  SCU_CCUCON0.U = __SCU_CCUCON0_VALUE;
; ..\cstart.c	   687  #endif
; ..\cstart.c	   688  
; ..\cstart.c	   689  #if defined SCU_CCUCON1 && defined __SCU_CCUCON1_VALUE
; ..\cstart.c	   690           if(__SCU_CCUCON1_INIT)  SCU_CCUCON1.U = __SCU_CCUCON1_VALUE;
; ..\cstart.c	   691  #endif
; ..\cstart.c	   692  
; ..\cstart.c	   693  #if defined SCU_CCUCON2 && defined __SCU_CCUCON2_VALUE
; ..\cstart.c	   694           if(__SCU_CCUCON2_INIT)  SCU_CCUCON2.U = __SCU_CCUCON2_VALUE;
; ..\cstart.c	   695  #endif
; ..\cstart.c	   696           
; ..\cstart.c	   697          /*
; ..\cstart.c	   698           * System Oscillator configuration
; ..\cstart.c	   699           */
; ..\cstart.c	   700  #if defined SCU_OSCCON && defined __SCU_OSCCON_VALUE
; ..\cstart.c	   701  #if __SCU_OSCCON_INIT
; ..\cstart.c	   702          SCU_OSCCON.U=__SCU_OSCCON_VALUE;
; ..\cstart.c	   703          
; ..\cstart.c	   704          while(SCU_OSCCON.B.PLLLV==0);           /* Oscillator not too low */
; ..\cstart.c	   705          while(SCU_OSCCON.B.PLLHV==0);           /* Oscillator not too high */
; ..\cstart.c	   706  #endif
; ..\cstart.c	   707  #endif
; ..\cstart.c	   708  
; ..\cstart.c	   709          /*
; ..\cstart.c	   710           * Configure PLL Prescaler Mode.
; ..\cstart.c	   711           */
; ..\cstart.c	   712  #if defined SCU_PLLCON1 && defined __SCU_PLLCON1_VALUE
; ..\cstart.c	   713  #if __SCU_PLLCON1_INIT
; ..\cstart.c	   714  #define __SCU_PLLCON1__K1DIV_VALUE      ((__SCU_PLLCON1_VALUE>>16)&0x3f)
; ..\cstart.c	   715          SCU_PLLCON1.B.K1DIV=__SCU_PLLCON1__K1DIV_VALUE;
; ..\cstart.c	   716          while(SCU_PLLSTAT.B.K1RDY==0);          /* Wait until K1-Divider is ready to operate */
; ..\cstart.c	   717  #endif
; ..\cstart.c	   718  #endif
; ..\cstart.c	   719  
; ..\cstart.c	   720  #if defined SCU_PLLCON0 && defined __SCU_PLLCON0_VALUE
; ..\cstart.c	   721  #if     __SCU_PLLCON0_INIT
; ..\cstart.c	   722          SCU_PLLCON0.B.VCOBYP=1;                 /* Enabled the VCO Bypass Mode */
; ..\cstart.c	   723          while(SCU_PLLSTAT.B.VCOBYST==0);        /* Wait until prescaler mode is entered */
; ..\cstart.c	   724  
; ..\cstart.c	   725  #define __SCU_PLLCON0__VCOPWD_VALUE     ((__SCU_PLLCON0_VALUE>>1)&0x1)
; ..\cstart.c	   726  #define __SCU_PLLCON0__NDIV_VALUE       ((__SCU_PLLCON0_VALUE>>9)&0x7f)
; ..\cstart.c	   727  #define __SCU_PLLCON0__PDIV_VALUE       ((__SCU_PLLCON0_VALUE>>24)&0xf)
; ..\cstart.c	   728          SCU_PLLCON0.B.PDIV=__SCU_PLLCON0__PDIV_VALUE;
; ..\cstart.c	   729          SCU_PLLCON0.B.NDIV=__SCU_PLLCON0__NDIV_VALUE;
; ..\cstart.c	   730          SCU_PLLCON0.B.VCOPWD=__SCU_PLLCON0__VCOPWD_VALUE; /* power down VCO */
; ..\cstart.c	   731  
; ..\cstart.c	   732  #if __SCU_PLLCON0__VCOPWD_VALUE==0
; ..\cstart.c	   733          /*
; ..\cstart.c	   734           * Configure PLL normal mode.
; ..\cstart.c	   735           */
; ..\cstart.c	   736          SCU_PLLCON0.B.OSCDISCDIS=1;             /* Automatic oscillator disconnect disabled */
; ..\cstart.c	   737          SCU_PLLCON0.B.CLRFINDIS=1;              /* Connect VCO to the oscillator */
; ..\cstart.c	   738          while(SCU_PLLSTAT.B.FINDIS==1);         /* Wait until oscillator is connected to the VCO */
; ..\cstart.c	   739          SCU_PLLCON0.B.RESLD=1;                  /* Restart VCO lock detection */
; ..\cstart.c	   740          while(SCU_PLLSTAT.B.VCOLOCK==0);        /* Wait until the VCO becomes locked */
; ..\cstart.c	   741          SCU_PLLCON0.B.VCOBYP=0;                 /* Disable the VCO Bypass Mode */
; ..\cstart.c	   742          while(SCU_PLLSTAT.B.VCOBYST==1);        /* Wait until normal mode is entered */
; ..\cstart.c	   743          SCU_PLLCON0.B.OSCDISCDIS=0;             /* Automatic oscillator disconnect enabled */
; ..\cstart.c	   744  #endif
; ..\cstart.c	   745  #endif
; ..\cstart.c	   746  #endif
; ..\cstart.c	   747  
; ..\cstart.c	   748  #if defined SCU_SYSPLLCON0 && defined __SCU_SYSPLLCON0_VALUE
; ..\cstart.c	   749          /*
; ..\cstart.c	   750           *      AURIX PLUS System PLL Configuration
; ..\cstart.c	   751           */
; ..\cstart.c	   752  #if __SCU_SYSPLLCON0_INIT
; ..\cstart.c	   753  #define __SCU_SYSPLLCON0__NDIV_VALUE    ((__SCU_SYSPLLCON0_VALUE>>9)&0xff)
; ..\cstart.c	   754  #define __SCU_SYSPLLCON0__PDIV_VALUE    ((__SCU_SYSPLLCON0_VALUE>>24)&0x7)
; ..\cstart.c	   755          /*
; ..\cstart.c	   756           * After power-on and system reset fsource=fback,
; ..\cstart.c	   757           * fOSC0 is used as clock source PLL and K2=6.
; ..\cstart.c	   758           */
; ..\cstart.c	   759          SCU_SYSPLLCON0.B.PDIV=__SCU_SYSPLLCON0__PDIV_VALUE;
; ..\cstart.c	   760          SCU_SYSPLLCON0.B.NDIV=__SCU_SYSPLLCON0__NDIV_VALUE;
; ..\cstart.c	   761  
; ..\cstart.c	   762          SCU_SYSPLLCON0.B.RESLD = 1;             /* Restart DCO Lock Detection */
; ..\cstart.c	   763          while(!SCU_SYSPLLSTAT.B.LOCK);          /* Wait for PLL lock */
; ..\cstart.c	   764  
; ..\cstart.c	   765          while(SCU_CCUCON0.B.LCK);               /* Wait for CCUCON0 unlocked */
; ..\cstart.c	   766          SCU_CCUCON0.B.CLKSEL = 1;               /* fsource=fpll */
; ..\cstart.c	   767          SCU_CCUCON0.B.UP = 1;                   /* Update */
; ..\cstart.c	   768  #endif
; ..\cstart.c	   769  #endif
; ..\cstart.c	   770  
; ..\cstart.c	   771          /*
; ..\cstart.c	   772           *      PLL K2 ramp up
; ..\cstart.c	   773           */
; ..\cstart.c	   774  #if ( defined SCU_PLLCON1 && defined __SCU_PLLCON1_VALUE ) || ( defined SCU_SYSPLLCON1 && defined SCU_SYSPLLCON0 && defined __SCU_SYSPLLCON1_VALUE )
; ..\cstart.c	   775  #if __SCU_PLLCON1_INIT || __SCU_SYSPLLCON1_INIT
; ..\cstart.c	   776  #if ( defined SCU_PLLCON1 )
; ..\cstart.c	   777  #define __K2DIV_VALUE   (__SCU_PLLCON1_VALUE&0x3f)
; ..\cstart.c	   778  #define __K2DIV         SCU_PLLCON1.B.K2DIV
; ..\cstart.c	   779  #define __NDIV          SCU_PLLCON0.B.NDIV
; ..\cstart.c	   780  #define __PDIV          SCU_PLLCON0.B.PDIV
; ..\cstart.c	   781  #else
; ..\cstart.c	   782  #define __K2DIV_VALUE   (__SCU_SYSPLLCON1_VALUE&0x3)
; ..\cstart.c	   783  #define __K2DIV         SCU_SYSPLLCON1.B.K2DIV
; ..\cstart.c	   784  #define __NDIV          SCU_SYSPLLCON0.B.NDIV
; ..\cstart.c	   785  #define __PDIV          SCU_SYSPLLCON0.B.PDIV
; ..\cstart.c	   786  #endif
; ..\cstart.c	   787  #if __PLL_K2_RAMPUP
; ..\cstart.c	   788  #if ( defined SCU_PLLSTAT || defined SCU_SYSPLLSTAT ) && defined __fOSC
; ..\cstart.c	   789  #if     (  defined _REGTC1167_H || defined _REGTC1197_H || defined _REGTC1337_H || defined _REGTC1367_H \ 
; ..\cstart.c	   790          || defined _REGTC1387_H || defined _REGTC1728_H \ 
; ..\cstart.c	   791          || defined _REGTC1736_H || defined _REGTC1738_H || defined _REGTC1746_H \ 
; ..\cstart.c	   792          || defined _REGTC1747_H || defined _REGTC1748_H || defined _REGTC1767_H || defined _REGTC1768_H \ 
; ..\cstart.c	   793          || defined _REGTC1782_H || defined _REGTC1784_H || defined _REGTC1184_H || defined _REGTC1797_H \ 
; ..\cstart.c	   794          || defined _REGTC1791_H || defined _REGTC1793_H || defined _REGTC1798_H || defined _REGTC1724_H \ 
; ..\cstart.c	   795          || defined _REGTC21X_H  || defined _REGTC22X_H  || defined _REGTC23X_ADAS_H || defined _REGTC23X_H \ 
; ..\cstart.c	   796          || defined _REGTC27X_H  || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H \ 
; ..\cstart.c	   797          || defined _REGTC26X_H  || defined _REGTC26XB_H || defined _REGTC29X_H  || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   798  #if ( defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   799  #define PLL_K2_RAMPUP_STM_CLC_RMC       1
; ..\cstart.c	   800  #else
; ..\cstart.c	   801  #define PLL_K2_RAMPUP_STM_CLC_RMC       (STM_CLC.B.RMC)
; ..\cstart.c	   802  #endif
; ..\cstart.c	   803  #if ( defined _REGTC1337_H || defined _REGTC1367_H || defined _REGTC1387_H || defined _REGTC1768_H )
; ..\cstart.c	   804  #define PLL_K2_RAMPUP_SYSCLK(CPUCLK)    (CPUCLK)
; ..\cstart.c	   805  #else
; ..\cstart.c	   806  #if ( defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H )
; ..\cstart.c	   807  #define PLL_K2_RAMPUP_SYSCLK(CPUCLK)    (CPUCLK/SCU_CCUCON1.B.STMDIV)
; ..\cstart.c	   808  #else
; ..\cstart.c	   809  #if ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   810  #define PLL_K2_RAMPUP_SYSCLK(CPUCLK)    (CPUCLK/SCU_CCUCON0.B.STMDIV)   
; ..\cstart.c	   811  #else
; ..\cstart.c	   812  #define PLL_K2_RAMPUP_SYSCLK(CPUCLK)    (CPUCLK/(SCU_CCUCON0.B.FPIDIV+1))
; ..\cstart.c	   813  #endif
; ..\cstart.c	   814  #endif
; ..\cstart.c	   815  #endif
; ..\cstart.c	   816  #define USECCLK         (PLL_K2_RAMPUP_SYSCLK(((__NDIV+1)*(__fOSC/1000000))/((__PDIV+1)*(__K2DIV+1)))/PLL_K2_RAMPUP_STM_CLC_RMC)
; ..\cstart.c	   817  #if ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	   818  #define USEC            100             /* wait 100 usec */
; ..\cstart.c	   819  #else
; ..\cstart.c	   820  #define USEC            20              /* wait 20 usec */
; ..\cstart.c	   821  #endif
; ..\cstart.c	   822  #define WAITUSEC        (USECCLK*USEC)
; ..\cstart.c	   823  #endif
; ..\cstart.c	   824  #endif
; ..\cstart.c	   825  #pragma tradeoff 0      /* avoid call to run-time function */
; ..\cstart.c	   826          while ( __K2DIV > __K2DIV_VALUE )
; ..\cstart.c	   827          {
; ..\cstart.c	   828                  unsigned int wait;
; ..\cstart.c	   829  
; ..\cstart.c	   830                  __K2DIV-=1;
; ..\cstart.c	   831                  wait = SYSTIME_LOW+WAITUSEC;
; ..\cstart.c	   832  
; ..\cstart.c	   833                  while( SYSTIME_LOW < wait ) ;
; ..\cstart.c	   834          }
; ..\cstart.c	   835  #pragma tradeoff restore
; ..\cstart.c	   836  #else
; ..\cstart.c	   837          __K2DIV=__K2DIV_VALUE;
; ..\cstart.c	   838  #endif
; ..\cstart.c	   839  #endif
; ..\cstart.c	   840  #endif
; ..\cstart.c	   841  
; ..\cstart.c	   842          /*
; ..\cstart.c	   843           * Configure flash registers.
; ..\cstart.c	   844           */
; ..\cstart.c	   845  #if defined FLASH0_FCON && defined __FLASH0_FCON_VALUE
; ..\cstart.c	   846          if(__FLASH0_FCON_INIT)  FLASH0_FCON.U = __FLASH0_FCON_VALUE;        
; ..\cstart.c	   847  #endif
; ..\cstart.c	   848  #if defined FLASH1_FCON && defined __FLASH1_FCON_VALUE
; ..\cstart.c	   849          if(__FLASH1_FCON_INIT)  FLASH1_FCON.U = __FLASH1_FCON_VALUE;        
; ..\cstart.c	   850  #endif
; ..\cstart.c	   851          
; ..\cstart.c	   852          /*
; ..\cstart.c	   853           * Configure system clock register.
; ..\cstart.c	   854           */
; ..\cstart.c	   855  #if defined STM_CLC && defined __STM_CLC_VALUE
; ..\cstart.c	   856          if(__STM_CLC_INIT)  STM_CLC.U = __STM_CLC_VALUE;        
; ..\cstart.c	   857  #endif
; ..\cstart.c	   858  
; ..\cstart.c	   859          /*
; ..\cstart.c	   860           * Enable the GTM to get MCS memory access,
; ..\cstart.c	   861           * required for MCS initialization which
; ..\cstart.c	   862           * is performed by _c_init.
; ..\cstart.c	   863           */
; ..\cstart.c	   864  #if defined GTM_CLC && defined __GTM_CLC_VALUE
; ..\cstart.c	   865          if(__GTM_CLC_INIT)  GTM_CLC.U = __GTM_CLC_VALUE;
; ..\cstart.c	   866  #endif
; ..\cstart.c	   867  
; ..\cstart.c	   868          /*
; ..\cstart.c	   869           * Set the rounding mode (PSW.RM)
; ..\cstart.c	   870           */
; ..\cstart.c	   871  #ifdef __RM_INIT
; ..\cstart.c	   872  #if __RM_INIT
; ..\cstart.c	   873          __fesetround( __RM_VALUE );
; ..\cstart.c	   874  #endif
; ..\cstart.c	   875  #endif
; ..\cstart.c	   876          
; ..\cstart.c	   877          /*
; ..\cstart.c	   878           * Set the ENDINIT bit in the WDT_CON0 register again
; ..\cstart.c	   879           * to enable the write-protection.
; ..\cstart.c	   880           */
; ..\cstart.c	   881          endinit_set(_ENDINIT_ENABLE);
; ..\cstart.c	   882  
; ..\cstart.c	   883  #if ( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	   884          /*
; ..\cstart.c	   885           * Set the ENDINIT bit in the WDTSCON0 register to enable the
; ..\cstart.c	   886           * safety-critical register write-protection.
; ..\cstart.c	   887           */
; ..\cstart.c	   888          safety_endinit_set(_ENDINIT_ENABLE);
; ..\cstart.c	   889  #endif
; ..\cstart.c	   890          
; ..\cstart.c	   891          /*
; ..\cstart.c	   892           * Initialize Bus configuration registers:
; ..\cstart.c	   893           * Set register-values according to define's created by the GUI
; ..\cstart.c	   894           * 
; ..\cstart.c	   895           * The recommended sequence of setting registers is as follows:
; ..\cstart.c	   896           * 1.EBUCON
; ..\cstart.c	   897           * 2.All other EBU registers except SDRAM specific registers
; ..\cstart.c	   898           * 3.SDRMCON0
; ..\cstart.c	   899           * 4.SDRMMOD0
; ..\cstart.c	   900           * 5.SDRMREF0
; ..\cstart.c	   901           * 6.SDRMCON1
; ..\cstart.c	   902           * 7.SDRMMOD1
; ..\cstart.c	   903           * 8.SDRMREF1
; ..\cstart.c	   904           */
; ..\cstart.c	   905  #if defined EBU_CON && defined __EBU_CON_VALUE
; ..\cstart.c	   906          if(__EBU_CON_INIT)  EBU_CON.U = __EBU_CON_VALUE;
; ..\cstart.c	   907  #endif
; ..\cstart.c	   908  #if defined EBU_ADDRSEL0 && defined __EBU_ADDRSEL0_VALUE
; ..\cstart.c	   909          if(__EBU_ADDRSEL0_INIT)  EBU_ADDRSEL0.U = __EBU_ADDRSEL0_VALUE;
; ..\cstart.c	   910  #endif
; ..\cstart.c	   911  #if defined EBU_ADDRSEL1 && defined __EBU_ADDRSEL1_VALUE
; ..\cstart.c	   912          if(__EBU_ADDRSEL1_INIT)  EBU_ADDRSEL1.U = __EBU_ADDRSEL1_VALUE;
; ..\cstart.c	   913  #endif
; ..\cstart.c	   914  #if defined EBU_ADDRSEL2 && defined __EBU_ADDRSEL2_VALUE
; ..\cstart.c	   915          if(__EBU_ADDRSEL2_INIT)  EBU_ADDRSEL2.U = __EBU_ADDRSEL2_VALUE;
; ..\cstart.c	   916  #endif
; ..\cstart.c	   917  #if defined EBU_ADDRSEL3 && defined __EBU_ADDRSEL3_VALUE
; ..\cstart.c	   918          if(__EBU_ADDRSEL3_INIT)  EBU_ADDRSEL3.U = __EBU_ADDRSEL3_VALUE;
; ..\cstart.c	   919  #endif
; ..\cstart.c	   920  #if defined EBU_ADDRSEL4 && defined __EBU_ADDRSEL4_VALUE
; ..\cstart.c	   921          if(__EBU_ADDRSEL4_INIT)  EBU_ADDRSEL4.U = __EBU_ADDRSEL4_VALUE;
; ..\cstart.c	   922  #endif
; ..\cstart.c	   923  #if defined EBU_ADDRSEL5 && defined __EBU_ADDRSEL5_VALUE
; ..\cstart.c	   924          if(__EBU_ADDRSEL5_INIT)  EBU_ADDRSEL5.U = __EBU_ADDRSEL5_VALUE;
; ..\cstart.c	   925  #endif
; ..\cstart.c	   926  #if defined EBU_ADDRSEL6 && defined __EBU_ADDRSEL6_VALUE
; ..\cstart.c	   927          if(__EBU_ADDRSEL6_INIT)  EBU_ADDRSEL6.U = __EBU_ADDRSEL6_VALUE;
; ..\cstart.c	   928  #endif
; ..\cstart.c	   929  #if defined EBU_BFCON && defined __EBU_BFCON_VALUE
; ..\cstart.c	   930          if(__EBU_BFCON_INIT)  EBU_BFCON.U = __EBU_BFCON_VALUE;
; ..\cstart.c	   931  #endif
; ..\cstart.c	   932  #if defined EBU_BUSAP0 && defined __EBU_BUSAP0_VALUE
; ..\cstart.c	   933          if(__EBU_BUSAP0_INIT)  EBU_BUSAP0.U = __EBU_BUSAP0_VALUE;
; ..\cstart.c	   934  #endif
; ..\cstart.c	   935  #if defined EBU_BUSAP1 && defined __EBU_BUSAP1_VALUE
; ..\cstart.c	   936          if(__EBU_BUSAP1_INIT)  EBU_BUSAP1.U = __EBU_BUSAP1_VALUE;
; ..\cstart.c	   937  #endif
; ..\cstart.c	   938  #if defined EBU_BUSAP2 && defined __EBU_BUSAP2_VALUE
; ..\cstart.c	   939          if(__EBU_BUSAP2_INIT)  EBU_BUSAP2.U = __EBU_BUSAP2_VALUE;
; ..\cstart.c	   940  #endif
; ..\cstart.c	   941  #if defined EBU_BUSAP3 && defined __EBU_BUSAP3_VALUE
; ..\cstart.c	   942          if(__EBU_BUSAP3_INIT)  EBU_BUSAP3.U = __EBU_BUSAP3_VALUE;
; ..\cstart.c	   943  #endif
; ..\cstart.c	   944  #if defined EBU_BUSAP4 && defined __EBU_BUSAP4_VALUE
; ..\cstart.c	   945          if(__EBU_BUSAP4_INIT)  EBU_BUSAP4.U = __EBU_BUSAP4_VALUE;
; ..\cstart.c	   946  #endif
; ..\cstart.c	   947  #if defined EBU_BUSAP5 && defined __EBU_BUSAP5_VALUE
; ..\cstart.c	   948          if(__EBU_BUSAP5_INIT)  EBU_BUSAP5.U = __EBU_BUSAP5_VALUE;
; ..\cstart.c	   949  #endif
; ..\cstart.c	   950  #if defined EBU_BUSAP6 && defined __EBU_BUSAP6_VALUE
; ..\cstart.c	   951          if(__EBU_BUSAP6_INIT)  EBU_BUSAP6.U = __EBU_BUSAP6_VALUE;
; ..\cstart.c	   952  #endif
; ..\cstart.c	   953  #if defined EBU_BUSCON0 && defined __EBU_BUSCON0_VALUE
; ..\cstart.c	   954          if(__EBU_BUSCON0_INIT)  EBU_BUSCON0.U = __EBU_BUSCON0_VALUE;
; ..\cstart.c	   955  #endif
; ..\cstart.c	   956  #if defined EBU_BUSCON1 && defined __EBU_BUSCON1_VALUE
; ..\cstart.c	   957          if(__EBU_BUSCON1_INIT)  EBU_BUSCON1.U = __EBU_BUSCON1_VALUE;
; ..\cstart.c	   958  #endif
; ..\cstart.c	   959  #if defined EBU_BUSCON2 && defined __EBU_BUSCON2_VALUE
; ..\cstart.c	   960          if(__EBU_BUSCON2_INIT)  EBU_BUSCON2.U = __EBU_BUSCON2_VALUE;
; ..\cstart.c	   961  #endif
; ..\cstart.c	   962  #if defined EBU_BUSCON3 && defined __EBU_BUSCON3_VALUE
; ..\cstart.c	   963          if(__EBU_BUSCON3_INIT)  EBU_BUSCON3.U = __EBU_BUSCON3_VALUE;
; ..\cstart.c	   964  #endif
; ..\cstart.c	   965  #if defined EBU_BUSCON4 && defined __EBU_BUSCON4_VALUE
; ..\cstart.c	   966          if(__EBU_BUSCON4_INIT)  EBU_BUSCON4.U = __EBU_BUSCON4_VALUE;
; ..\cstart.c	   967  #endif
; ..\cstart.c	   968  #if defined EBU_BUSCON5 && defined __EBU_BUSCON5_VALUE
; ..\cstart.c	   969          if(__EBU_BUSCON5_INIT)  EBU_BUSCON5.U = __EBU_BUSCON5_VALUE;
; ..\cstart.c	   970  #endif
; ..\cstart.c	   971  #if defined EBU_BUSCON6 && defined __EBU_BUSCON6_VALUE
; ..\cstart.c	   972          if(__EBU_BUSCON6_INIT)  EBU_BUSCON6.U = __EBU_BUSCON6_VALUE;
; ..\cstart.c	   973  #endif
; ..\cstart.c	   974  #if defined EBU_EMUAS && defined __EBU_EMUAS_VALUE
; ..\cstart.c	   975          if(__EBU_EMUAS_INIT)  EBU_EMUAS.U = __EBU_EMUAS_VALUE;
; ..\cstart.c	   976  #endif
; ..\cstart.c	   977  #if defined EBU_EMUBAP && defined __EBU_EMUBAP_VALUE
; ..\cstart.c	   978          if(__EBU_EMUBAP_INIT)  EBU_EMUBAP.U = __EBU_EMUBAP_VALUE;
; ..\cstart.c	   979  #endif
; ..\cstart.c	   980  #if defined EBU_EMUBC && defined __EBU_EMUBC_VALUE
; ..\cstart.c	   981          if(__EBU_EMUBC_INIT)  EBU_EMUBC.U = __EBU_EMUBC_VALUE;
; ..\cstart.c	   982  #endif
; ..\cstart.c	   983  #if defined EBU_EMUCON && defined __EBU_EMUCON_VALUE
; ..\cstart.c	   984          if(__EBU_EMUCON_INIT)  EBU_EMUCON.U = __EBU_EMUCON_VALUE;
; ..\cstart.c	   985  #endif
; ..\cstart.c	   986  #if defined EBU_EMUOVL && defined __EBU_EMUOVL_VALUE
; ..\cstart.c	   987          if(__EBU_EMUOVL_INIT)  EBU_EMUOVL.U = __EBU_EMUOVL_VALUE;
; ..\cstart.c	   988  #endif
; ..\cstart.c	   989  #if defined EBU_SDRMCON0 && defined __EBU_SDRMCON0_VALUE
; ..\cstart.c	   990          if(__EBU_SDRMCON0_INIT)  EBU_SDRMCON0.U = __EBU_SDRMCON0_VALUE;
; ..\cstart.c	   991  #endif
; ..\cstart.c	   992  #if defined EBU_SDRMOD0 && defined __EBU_SDRMOD0_VALUE
; ..\cstart.c	   993          if(__EBU_SDRMOD0_INIT)  EBU_SDRMOD0.U = __EBU_SDRMOD0_VALUE;
; ..\cstart.c	   994  #endif
; ..\cstart.c	   995  #if defined EBU_SDRMREF0 && defined __EBU_SDRMREF0_VALUE
; ..\cstart.c	   996          if(__EBU_SDRMREF0_INIT)  EBU_SDRMREF0.U = __EBU_SDRMREF0_VALUE;
; ..\cstart.c	   997  #endif
; ..\cstart.c	   998  #if defined EBU_SDRMCON1 && defined __EBU_SDRMCON1_VALUE
; ..\cstart.c	   999          if(__EBU_SDRMCON1_INIT)  EBU_SDRMCON1.U = __EBU_SDRMCON1_VALUE;
; ..\cstart.c	  1000  #endif
; ..\cstart.c	  1001  #if defined EBU_SDRMOD1 && defined __EBU_SDRMOD1_VALUE
; ..\cstart.c	  1002          if(__EBU_SDRMOD1_INIT)  EBU_SDRMOD1.U = __EBU_SDRMOD1_VALUE;
; ..\cstart.c	  1003  #endif
; ..\cstart.c	  1004  #if defined EBU_SDRMREF1 && defined __EBU_SDRMREF1_VALUE
; ..\cstart.c	  1005          if(__EBU_SDRMREF1_INIT)  EBU_SDRMREF1.U = __EBU_SDRMREF1_VALUE;
; ..\cstart.c	  1006  #endif
; ..\cstart.c	  1007  #if defined CBS_MCDBBS && defined __CBS_MCDBBS_VALUE
; ..\cstart.c	  1008          if(__CBS_MCDBBS_INIT)  CBS_MCDBBS .U = __CBS_MCDBBS_VALUE;
; ..\cstart.c	  1009  #endif
; ..\cstart.c	  1010  #if defined SBCU_CON && defined __SBCU_CON_VALUE
; ..\cstart.c	  1011          if(__SBCU_CON_INIT)  SBCU_CON.U = __SBCU_CON_VALUE;
; ..\cstart.c	  1012  #endif
; ..\cstart.c	  1013  #if defined EBU_BUSRAP1 && defined __EBU_BUSRAP1_VALUE
; ..\cstart.c	  1014          if(__EBU_BUSRAP1_INIT)  EBU_BUSRAP1.U = __EBU_BUSRAP1_VALUE;
; ..\cstart.c	  1015  #endif
; ..\cstart.c	  1016  #if defined EBU_BUSRAP0 && defined __EBU_BUSRAP0_VALUE
; ..\cstart.c	  1017          if(__EBU_BUSRAP0_INIT)  EBU_BUSRAP0.U = __EBU_BUSRAP0_VALUE;
; ..\cstart.c	  1018  #endif
; ..\cstart.c	  1019  #if defined EBU_BUSRAP2 && defined __EBU_BUSRAP2_VALUE
; ..\cstart.c	  1020          if(__EBU_BUSRAP2_INIT)  EBU_BUSRAP2.U = __EBU_BUSRAP2_VALUE;
; ..\cstart.c	  1021  #endif
; ..\cstart.c	  1022  #if defined EBU_BUSRAP3 && defined __EBU_BUSRAP3_VALUE
; ..\cstart.c	  1023          if(__EBU_BUSRAP3_INIT)  EBU_BUSRAP3.U = __EBU_BUSRAP3_VALUE;
; ..\cstart.c	  1024  #endif
; ..\cstart.c	  1025  #if defined EBU_BUSRCON0 && defined __EBU_BUSRCON0_VALUE
; ..\cstart.c	  1026          if(__EBU_BUSRCON0_INIT)  EBU_BUSRCON0.U = __EBU_BUSRCON0_VALUE;
; ..\cstart.c	  1027  #endif
; ..\cstart.c	  1028  #if defined EBU_BUSRCON1 && defined __EBU_BUSRCON1_VALUE
; ..\cstart.c	  1029          if(__EBU_BUSRCON1_INIT)  EBU_BUSRCON1.U = __EBU_BUSRCON1_VALUE;
; ..\cstart.c	  1030  #endif
; ..\cstart.c	  1031  #if defined EBU_BUSRCON2 && defined __EBU_BUSRCON2_VALUE
; ..\cstart.c	  1032          if(__EBU_BUSRCON2_INIT)  EBU_BUSRCON2.U = __EBU_BUSRCON2_VALUE;
; ..\cstart.c	  1033  #endif
; ..\cstart.c	  1034  #if defined EBU_BUSRCON3 && defined __EBU_BUSRCON3_VALUE
; ..\cstart.c	  1035          if(__EBU_BUSRCON3_INIT)  EBU_BUSRCON3.U = __EBU_BUSRCON3_VALUE;
; ..\cstart.c	  1036  #endif
; ..\cstart.c	  1037  #if defined EBU_BUSWAP0 && defined __EBU_BUSWAP0_VALUE
; ..\cstart.c	  1038          if(__EBU_BUSWAP0_INIT)  EBU_BUSWAP0.U = __EBU_BUSWAP0_VALUE;
; ..\cstart.c	  1039  #endif
; ..\cstart.c	  1040  #if defined EBU_BUSWAP1 && defined __EBU_BUSWAP1_VALUE
; ..\cstart.c	  1041          if(__EBU_BUSWAP1_INIT)  EBU_BUSWAP1.U = __EBU_BUSWAP1_VALUE;
; ..\cstart.c	  1042  #endif
; ..\cstart.c	  1043  #if defined EBU_BUSWAP2 && defined __EBU_BUSWAP2_VALUE
; ..\cstart.c	  1044          if(__EBU_BUSWAP2_INIT)  EBU_BUSWAP2.U = __EBU_BUSWAP2_VALUE;
; ..\cstart.c	  1045  #endif
; ..\cstart.c	  1046  #if defined EBU_BUSWAP3 && defined __EBU_BUSWAP3_VALUE
; ..\cstart.c	  1047          if(__EBU_BUSWAP3_INIT)  EBU_BUSWAP3.U = __EBU_BUSWAP3_VALUE;
; ..\cstart.c	  1048  #endif
; ..\cstart.c	  1049  #if defined EBU_BUSWCON0 && defined __EBU_BUSWCON0_VALUE
; ..\cstart.c	  1050          if(__EBU_BUSWCON0_INIT)  EBU_BUSWCON0.U = __EBU_BUSWCON0_VALUE;
; ..\cstart.c	  1051  #endif
; ..\cstart.c	  1052  #if defined EBU_BUSWCON1 && defined __EBU_BUSWCON1_VALUE
; ..\cstart.c	  1053          if(__EBU_BUSWCON1_INIT)  EBU_BUSWCON1.U = __EBU_BUSWCON1_VALUE;
; ..\cstart.c	  1054  #endif
; ..\cstart.c	  1055  #if defined EBU_BUSWCON2 && defined __EBU_BUSWCON2_VALUE
; ..\cstart.c	  1056          if(__EBU_BUSWCON2_INIT)  EBU_BUSWCON2.U = __EBU_BUSWCON2_VALUE;
; ..\cstart.c	  1057  #endif
; ..\cstart.c	  1058  #if defined EBU_BUSWCON3 && defined __EBU_BUSWCON3_VALUE
; ..\cstart.c	  1059          if(__EBU_BUSWCON3_INIT)  EBU_BUSWCON3.U = __EBU_BUSWCON3_VALUE;
; ..\cstart.c	  1060  #endif
; ..\cstart.c	  1061  #if defined EBU_EXTBOOT && defined __EBU_EXTBOOT_VALUE
; ..\cstart.c	  1062          if(__EBU_EXTBOOT_INIT)  EBU_EXTBOOT.U = __EBU_EXTBOOT_VALUE;
; ..\cstart.c	  1063  #endif
; ..\cstart.c	  1064  #if defined EBU_MODCON && defined __EBU_MODCON_VALUE
; ..\cstart.c	  1065          if(__EBU_MODCON_INIT)  EBU_MODCON.U = __EBU_MODCON_VALUE;
; ..\cstart.c	  1066  #endif
; ..\cstart.c	  1067  #if defined EBU_DDRNCON && defined __EBU_DDRNCON_VALUE
; ..\cstart.c	  1068          if(__EBU_DDRNCON_INIT)  EBU_DDRNCON.U = __EBU_DDRNCON_VALUE;
; ..\cstart.c	  1069  #endif
; ..\cstart.c	  1070  #if defined EBU_DDRNMOD && defined __EBU_DDRNMOD_VALUE
; ..\cstart.c	  1071          if(__EBU_DDRNMOD_INIT)  EBU_DDRNMOD.U = __EBU_DDRNMOD_VALUE;
; ..\cstart.c	  1072  #endif
; ..\cstart.c	  1073  #if defined EBU_DDRNMOD2 && defined __EBU_DDRNMOD2_VALUE
; ..\cstart.c	  1074          if(__EBU_DDRNMOD2_INIT)  EBU_DDRNMOD2.U = __EBU_DDRNMOD2_VALUE;
; ..\cstart.c	  1075  #endif
; ..\cstart.c	  1076  #if defined EBU_DDRNPRLD && defined __EBU_DDRNPRLD_VALUE
; ..\cstart.c	  1077          if(__EBU_DDRNPRLD_INIT)  EBU_DDRNPRLD.U = __EBU_DDRNPRLD_VALUE;
; ..\cstart.c	  1078  #endif
; ..\cstart.c	  1079  #if defined EBU_DDRNTAG0 && defined __EBU_DDRNTAG0_VALUE
; ..\cstart.c	  1080          if(__EBU_DDRNTAG0_INIT)  EBU_DDRNTAG0.U = __EBU_DDRNTAG0_VALUE;
; ..\cstart.c	  1081  #endif
; ..\cstart.c	  1082  #if defined EBU_DDRNTAG1 && defined __EBU_DDRNTAG1_VALUE
; ..\cstart.c	  1083          if(__EBU_DDRNTAG1_INIT)  EBU_DDRNTAG1.U = __EBU_DDRNTAG1_VALUE;
; ..\cstart.c	  1084  #endif
; ..\cstart.c	  1085  #if defined EBU_DDRNTAG2 && defined __EBU_DDRNTAG2_VALUE
; ..\cstart.c	  1086          if(__EBU_DDRNTAG2_INIT)  EBU_DDRNTAG2.U = __EBU_DDRNTAG2_VALUE;
; ..\cstart.c	  1087  #endif
; ..\cstart.c	  1088  #if defined EBU_DDRNTAG3 && defined __EBU_DDRNTAG3_VALUE
; ..\cstart.c	  1089          if(__EBU_DDRNTAG3_INIT)  EBU_DDRNTAG3.U = __EBU_DDRNTAG3_VALUE;
; ..\cstart.c	  1090  #endif
; ..\cstart.c	  1091  #if defined EBU_DLLCON && defined __EBU_DLLCON_VALUE
; ..\cstart.c	  1092          if(__EBU_DLLCON_INIT)  EBU_DLLCON.U = __EBU_DLLCON_VALUE;
; ..\cstart.c	  1093  #endif
; ..\cstart.c	  1094  #if defined EBU_SDRMCON && defined __EBU_SDRMCON_VALUE
; ..\cstart.c	  1095          if(__EBU_SDRMCON_INIT)  EBU_SDRMCON.U = __EBU_SDRMCON_VALUE;
; ..\cstart.c	  1096  #endif
; ..\cstart.c	  1097  #if defined EBU_SDRMOD && defined __EBU_SDRMOD_VALUE
; ..\cstart.c	  1098          if(__EBU_SDRMOD_INIT)  EBU_SDRMOD.U = __EBU_SDRMOD_VALUE;
; ..\cstart.c	  1099  #endif
; ..\cstart.c	  1100  #if defined EBU_SDRMREF && defined __EBU_SDRMREF_VALUE
; ..\cstart.c	  1101          if(__EBU_SDRMREF_INIT)  EBU_SDRMREF.U = __EBU_SDRMREF_VALUE;
; ..\cstart.c	  1102  #endif
; ..\cstart.c	  1103  #if defined EBU_SDRSTAT && defined __EBU_SDRSTAT_VALUE
; ..\cstart.c	  1104          if(__EBU_SDRSTAT_INIT)  EBU_SDRSTAT.U = __EBU_SDRSTAT_VALUE;
; ..\cstart.c	  1105  #endif
; ..\cstart.c	  1106  
; ..\cstart.c	  1107          /*
; ..\cstart.c	  1108           * Initialize global address registers a0/a1 to support
; ..\cstart.c	  1109           * __a0/__a1 storage qualifiers of the C compiler.
; ..\cstart.c	  1110           */
; ..\cstart.c	  1111  #if __A0A1_INIT
; ..\cstart.c	  1112          void * a0 = _SMALL_DATA_;        
; ..\cstart.c	  1113          __asm( "mov.aa\ta0,%0"::"a"(a0) );
; ..\cstart.c	  1114  
; ..\cstart.c	  1115          void * a1 = _LITERAL_DATA_;        
; ..\cstart.c	  1116          __asm( "mov.aa\ta1,%0"::"a"(a1) );
; ..\cstart.c	  1117  #endif
; ..\cstart.c	  1118  
; ..\cstart.c	  1119          /*
; ..\cstart.c	  1120           * Initialize global address registers a8/a9 to support
; ..\cstart.c	  1121           * __a8/__a9 storage qualifiers of the C compiler. A8 and A9
; ..\cstart.c	  1122           * are reserved for OS use, or for application use in cases 
; ..\cstart.c	  1123           * where the application ans OS are tightly coupled.
; ..\cstart.c	  1124           */
; ..\cstart.c	  1125  #if __A8A9_INIT
; ..\cstart.c	  1126          void * a8 = _A8_DATA_;        
; ..\cstart.c	  1127          __asm( "mov.aa\ta8,%0"::"a"(a8) );
; ..\cstart.c	  1128  
; ..\cstart.c	  1129          void * a9 = _A9_DATA_;        
; ..\cstart.c	  1130          __asm( "mov.aa\ta9,%0"::"a"(a9) );
; ..\cstart.c	  1131  #endif
; ..\cstart.c	  1132          
; ..\cstart.c	  1133          /* Setup the context save area linked list. */
; ..\cstart.c	  1134  #if __CSA_INIT
; ..\cstart.c	  1135          
; ..\cstart.c	  1136  #  if !__CPU_TC051_INITIAL__
; ..\cstart.c	  1137  #  define MAX_NR_OF_CSA_AREAS     1
; ..\cstart.c	  1138  extern int _lc_ub_csa_01[][16];    /* context save area 1 begin */
; ..\cstart.c	  1139  extern int _lc_ue_csa_01[][16];    /* context save area 1 end   */
; ..\cstart.c	  1140  static __far int (* const csa_area_begin[])[16] = { _lc_ub_csa_01 }; 
; ..\cstart.c	  1141  static __far int (* const csa_area_end[])[16]   = { _lc_ue_csa_01 };
; ..\cstart.c	  1142  #  else
; ..\cstart.c	  1143  #  define MAX_NR_OF_CSA_AREAS     3
; ..\cstart.c	  1144  extern int _lc_ub_csa_01[][16];    /* context save area 1 begin */
; ..\cstart.c	  1145  extern int _lc_ue_csa_01[][16];    /* context save area 1 end   */
; ..\cstart.c	  1146  extern int _lc_ub_csa_02[][16];    /* context save area 2 begin */
; ..\cstart.c	  1147  extern int _lc_ue_csa_02[][16];    /* context save area 2 end   */
; ..\cstart.c	  1148  extern int _lc_ub_csa_03[][16];    /* context save area 3 begin */
; ..\cstart.c	  1149  extern int _lc_ue_csa_03[][16];    /* context save area 3 end   */
; ..\cstart.c	  1150  static __far int (* const csa_area_begin[])[16] = { _lc_ub_csa_01, _lc_ub_csa_02, _lc_ub_csa_03 };        
; ..\cstart.c	  1151  static __far int (* const csa_area_end[])[16]   = { _lc_ue_csa_01, _lc_ue_csa_02, _lc_ue_csa_03 };
; ..\cstart.c	  1152  #  endif
; ..\cstart.c	  1153  
; ..\cstart.c	  1154          int  i, k;
; ..\cstart.c	  1155          int  no_of_csas;
; ..\cstart.c	  1156          int * csa;
; ..\cstart.c	  1157          unsigned int  seg_nr, seg_idx, pcxi_val=0;
; ..\cstart.c	  1158          _Bool first=true;
; ..\cstart.c	  1159          
; ..\cstart.c	  1160          for (i=0; i < MAX_NR_OF_CSA_AREAS; i++)
; ..\cstart.c	  1161          {
; ..\cstart.c	  1162                  /* first calculate nr of CSAs in this area */
; ..\cstart.c	  1163                  no_of_csas = csa_area_end[i] - csa_area_begin[i]; 
; ..\cstart.c	  1164                  
; ..\cstart.c	  1165                  for (k=0; k < no_of_csas; k++)
; ..\cstart.c	  1166                  {
; ..\cstart.c	  1167                          csa = csa_area_begin[i][k];
; ..\cstart.c	  1168                          /* Store null pointer in last CSA (= very first time!) */
; ..\cstart.c	  1169                          *csa = pcxi_val;                        
; ..\cstart.c	  1170  
; ..\cstart.c	  1171                          seg_nr  = (((unsigned int)csa >> 28) & 0xf) << 16;
; ..\cstart.c	  1172                          seg_idx = (((unsigned int)csa >> 6) & 0xffff);
; ..\cstart.c	  1173                          pcxi_val = seg_nr | seg_idx;
; ..\cstart.c	  1174                          if (first)
; ..\cstart.c	  1175                          {
; ..\cstart.c	  1176                                  first = false;                                
; ..\cstart.c	  1177                                  __mtcr(LCX, pcxi_val);
; ..\cstart.c	  1178                          }                        
; ..\cstart.c	  1179                  }
; ..\cstart.c	  1180                  __mtcr(FCX, pcxi_val);
; ..\cstart.c	  1181          }
; ..\cstart.c	  1182  #endif
; ..\cstart.c	  1183          
; ..\cstart.c	  1184          /*
; ..\cstart.c	  1185           * PMU_TC.004 workaround:
; ..\cstart.c	  1186           * The split mode is disabled on the LMB bus to workaround.
; ..\cstart.c	  1187           */
; ..\cstart.c	  1188  #if __PMU_TC004_INITIAL__  && defined LFI_CON
; ..\cstart.c	  1189          LFI_CON.U &= 0xfffffffe;        
; ..\cstart.c	  1190  #endif
; ..\cstart.c	  1191          
; ..\cstart.c	  1192          /*
; ..\cstart.c	  1193           * Initialize and clear C variables.
; ..\cstart.c	  1194           */
; ..\cstart.c	  1195  #if __C_INIT
; ..\cstart.c	  1196          _c_init();      /* initialize data */
; ..\cstart.c	  1197  #endif  
; ..\cstart.c	  1198  
; ..\cstart.c	  1199          /*
; ..\cstart.c	  1200           * initialize __clocks_per_sec,
; ..\cstart.c	  1201           * the oscillator frequency is defined by __fOSC.
; ..\cstart.c	  1202           */
; ..\cstart.c	  1203  #if __CLOCKS_PER_SEC_INIT
; ..\cstart.c	  1204          setclockpersec();
; ..\cstart.c	  1205  #endif  
; ..\cstart.c	  1206  
; ..\cstart.c	  1207          /* initialize profiling if required 
; ..\cstart.c	  1208           */        
; ..\cstart.c	  1209  #if __PROF_ENABLE__
; ..\cstart.c	  1210          __prof_init();
; ..\cstart.c	  1211  #endif
; ..\cstart.c	  1212  
; ..\cstart.c	  1213          /*
; ..\cstart.c	  1214           * Call a user function called _endinit() within one can initialize the 
; ..\cstart.c	  1215           * registers protected via the EndInit feature.
; ..\cstart.c	  1216           * Beware that protected registers are unlocked 
; ..\cstart.c	  1217           * for the duration of the Time-out Period only!
; ..\cstart.c	  1218           */
; ..\cstart.c	  1219  #ifdef _CALL_ENDINIT
; ..\cstart.c	  1220          endinit_set(_ENDINIT_DISABLE);  /* disable the write-protection */
; ..\cstart.c	  1221          _endinit();        
; ..\cstart.c	  1222          endinit_set(_ENDINIT_ENABLE);    /* enable the write-protection  */
; ..\cstart.c	  1223  #endif
; ..\cstart.c	  1224          
; ..\cstart.c	  1225          /*
; ..\cstart.c	  1226           * Call a user function before starting main().
; ..\cstart.c	  1227           */
; ..\cstart.c	  1228  #ifdef __CALL_INIT
; ..\cstart.c	  1229          _call_init();        
; ..\cstart.c	  1230  #endif
; ..\cstart.c	  1231  
; ..\cstart.c	  1232          /*
; ..\cstart.c	  1233           *      Download image to xc800 XRAM
; ..\cstart.c	  1234           */
; ..\cstart.c	  1235  #if ( defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	  1236  #if __XC800_INIT
; ..\cstart.c	  1237          _xc800_init();
; ..\cstart.c	  1238  #endif
; ..\cstart.c	  1239  #endif
; ..\cstart.c	  1240          
; ..\cstart.c	  1241  #if ( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	  1242  #if (__HALT_INIT_TC1 && (__HALT_VALUE_TC1 & 0x2)) || (__HALT_INIT_TC2 && (__HALT_VALUE_TC2 & 0x2)) || (__HALT_INIT_TC3 && (__HALT_VALUE_TC3 & 0x2)) || (__HALT_INIT_TC4 && (__HALT_VALUE_TC4 & 0x2)) || (__HALT_INIT_TC5 && (__HALT_VALUE_TC5 & 0x2))
; ..\cstart.c	  1243  #if __C_INIT || __CLOCKS_PER_SEC_INIT || __PROF_ENABLE__ || _CALL_ENDINIT || (defined __CALL_INIT)
; ..\cstart.c	  1244          __swapmskw( (unsigned int *)&_tcx_end_c_init, 0x1, 0x1 );       /* tc0 end of initialization */
; ..\cstart.c	  1245          /*
; ..\cstart.c	  1246           * Before calling main, which has code core association share,
; ..\cstart.c	  1247           * wait until all cores have done the global initializations
; ..\cstart.c	  1248           * to avoid race conditions on initialized shared global data.
; ..\cstart.c	  1249           */
; ..\cstart.c	  1250          while ( ( _tcx_end_c_init & 0x3f ) != 0x3f ) ;
; ..\cstart.c	  1251  #endif
; ..\cstart.c	  1252  #endif
; ..\cstart.c	  1253  #endif
; ..\cstart.c	  1254          
; ..\cstart.c	  1255          /*
; ..\cstart.c	  1256           * Call C main program.
; ..\cstart.c	  1257           */
; ..\cstart.c	  1258  #if __USE_ARGC_ARGV
; ..\cstart.c	  1259          exit( main( _argcv( argcv, __ARGCV_BUFSIZE ), (char **)argcv ) );
; ..\cstart.c	  1260  #else
; ..\cstart.c	  1261          exit( main( 0, NULL ) );                /* argc is 0 */
; ..\cstart.c	  1262  #endif
; ..\cstart.c	  1263  
; ..\cstart.c	  1264          /*
; ..\cstart.c	  1265           * Default trap vectors are resolved from the C-library.
; ..\cstart.c	  1266           */
; ..\cstart.c	  1267  #if __BTV_INIT
; ..\cstart.c	  1268  #  if __RESOLVE_TRAP_0
; ..\cstart.c	  1269  #    pragma extern  _trapmmu
; ..\cstart.c	  1270  #  endif
; ..\cstart.c	  1271  #  if __RESOLVE_TRAP_1
; ..\cstart.c	  1272  #    pragma extern  _trapprotection
; ..\cstart.c	  1273  #  endif
; ..\cstart.c	  1274  #  if __RESOLVE_TRAP_2
; ..\cstart.c	  1275  #    pragma extern  _trapinstruction
; ..\cstart.c	  1276  #  endif
; ..\cstart.c	  1277  #  if __RESOLVE_TRAP_3
; ..\cstart.c	  1278  #    pragma extern  _trapcontext
; ..\cstart.c	  1279  #  endif
; ..\cstart.c	  1280  #  if __RESOLVE_TRAP_4
; ..\cstart.c	  1281  #    pragma extern  _trapbus
; ..\cstart.c	  1282  #  endif
; ..\cstart.c	  1283  #  if __RESOLVE_TRAP_5
; ..\cstart.c	  1284  #    pragma extern  _trapassertion
; ..\cstart.c	  1285  #  endif
; ..\cstart.c	  1286  #  if __RESOLVE_TRAP_6
; ..\cstart.c	  1287  #    pragma extern  _trapsystem
; ..\cstart.c	  1288  #  endif
; ..\cstart.c	  1289  #  if __RESOLVE_TRAP_7
; ..\cstart.c	  1290  #    pragma extern  _trapnmi
; ..\cstart.c	  1291  #  endif
; ..\cstart.c	  1292  #endif
; ..\cstart.c	  1293          
; ..\cstart.c	  1294  }
; ..\cstart.c	  1295  
; ..\cstart.c	  1296  /**************************************************************************
; ..\cstart.c	  1297   *
; ..\cstart.c	  1298   * FUNCTION:     endinit_set
; ..\cstart.c	  1299   *
; ..\cstart.c	  1300   * DESCRIPTION:  Sets or Clears the ENDINIT bit in the WDT_CON0 register
; ..\cstart.c	  1301   *               in order to enabled or disable the write-protection for
; ..\cstart.c	  1302   *               registers protected via the EndInit feature
; ..\cstart.c	  1303   *               (ie. BTV, BIV, ISP, PCON0, DCON0).
; ..\cstart.c	  1304   *
; ..\cstart.c	  1305   *************************************************************************/
; ..\cstart.c	  1306  static void inline endinit_set( _endinit_t endinit_value )
; ..\cstart.c	  1307  {
; ..\cstart.c	  1308          unsigned int wdt_con0;
; ..\cstart.c	  1309  
; ..\cstart.c	  1310  #if !( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	  1311          unsigned int wdt_con1;
; ..\cstart.c	  1312  #endif
; ..\cstart.c	  1313          /*
; ..\cstart.c	  1314           * 1st step: Password access (create password and send to WDT_CON0)
; ..\cstart.c	  1315           */        
; ..\cstart.c	  1316          wdt_con0 = WDT_CON0.U;
	movh.a	a15,#61443
	lea	a15,[a15]@los(0xf0036100)
	fcall	.cocofun_1
.L259:

; ..\cstart.c	  1317  #if !( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	  1318          wdt_con1 = WDT_CON1.U;
; ..\cstart.c	  1319  #endif
; ..\cstart.c	  1320  
; ..\cstart.c	  1321          wdt_con0 &= 0xffffff01;         /* clear WDTLCK, WDTHPW0, WDTHPW1 */
; ..\cstart.c	  1322          wdt_con0 |= 0xf0;               /* set WDTHPW1 to 0xf */
; ..\cstart.c	  1323  #if ( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	  1324          wdt_con0 |= 0x1;                /* 1 must be written to ENDINIT for password access
; ..\cstart.c	  1325                                           * (but this will not actually modify the bit) */
; ..\cstart.c	  1326  #else
; ..\cstart.c	  1327          wdt_con1 &= 0x0c;               /* copy of WDT_CON1.DR and WDT_CON1.IR (d1) */
; ..\cstart.c	  1328          wdt_con0 |= wdt_con1;           /* HPW0 is WDT_CON1.DR | WDT_CON1.IR */
; ..\cstart.c	  1329  #endif
; ..\cstart.c	  1330          WDT_CON0.U = wdt_con0;
; ..\cstart.c	  1331  
; ..\cstart.c	  1332          /*
; ..\cstart.c	  1333           * 2nd step: Modify access, set the bit ENDINIT to 1 or 0 to allow access to
; ..\cstart.c	  1334           *           registers: WDT_CON1, BTV, BIV, ISP and mod_CLC
; ..\cstart.c	  1335           */
; ..\cstart.c	  1336          wdt_con0 &= 0xfffffff0;         /* clear WDTHPW0, WDTLCK, ENDINIT  */
; ..\cstart.c	  1337          wdt_con0 |= 0x02 | endinit_value;       /* WDTHPW0=0, WDTLCK=1, ENDINIT=0 */
; ..\cstart.c	  1338          __isync();
	isync
.L173:

; ..\cstart.c	  1339          WDT_CON0.U = wdt_con0;          
	st.w	[a15],d15
.L260:

; ..\cstart.c	  1340          WDT_CON0.U;                     /* read is required */
	ld.w	d15,[a15]
.L153:
	ret
.L152:
	
___endinit_clear_function_end:
	.size	_endinit_clear,___endinit_clear_function_end-_endinit_clear
.L47:
	; End of function
	
	.sdecl	'.text.cstart..cocofun_1',code,cluster('.cocofun_1')
	.sect	'.text.cstart..cocofun_1'
	.align	2
; Function .cocofun_1
.L8:
.cocofun_1:	.type	func
; Function body .cocofun_1, coco_iter:0
	ld.w	d15,[a15]
.L180:
	insert	d15,d15,#0,#1,#7
.L172:
	or	d15,#241
	st.w	[a15],d15
.L287:
	insert	d15,d15,#2,#0,#4
	fret
.L72:
	; End of function
	.sdecl	'.text.cstart._endinit_set',code,cluster('_endinit_set')
	.sect	'.text.cstart._endinit_set'
	.align	2
	
	.global	_endinit_set
; Function _endinit_set
.L10:
_endinit_set:	.type	func
	movh.a	a15,#61443
	lea	a15,[a15]@los(0xf0036100)
	fcall	.cocofun_2
.L265:
	isync
.L175:
	st.w	[a15],d15
.L266:
	ld.w	d15,[a15]
.L158:
	ret
.L157:
	
___endinit_set_function_end:
	.size	_endinit_set,___endinit_set_function_end-_endinit_set
.L52:
	; End of function
	
	.sdecl	'.text.cstart..cocofun_2',code,cluster('.cocofun_2')
	.sect	'.text.cstart..cocofun_2'
	.align	2
; Function .cocofun_2
.L12:
.cocofun_2:	.type	func
; Function body .cocofun_2, coco_iter:0
	ld.w	d15,[a15]
.L292:
	insert	d15,d15,#0,#1,#7
.L174:
	or	d15,#241
	st.w	[a15],d15
.L293:
	insert	d15,d15,#3,#0,#4
	fret
.L77:
	; End of function
	.sdecl	'.text.cstart._safety_endinit_clear',code,cluster('_safety_endinit_clear')
	.sect	'.text.cstart._safety_endinit_clear'
	.align	2
	
	.global	_safety_endinit_clear
; Function _safety_endinit_clear
.L14:
_safety_endinit_clear:	.type	func

; ..\cstart.c	  1341  }
; ..\cstart.c	  1342  
; ..\cstart.c	  1343  #if ( defined _REGUSERDEF16X_H || defined _REGUSERDEF162_H || defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	  1344  /**************************************************************************
; ..\cstart.c	  1345   *
; ..\cstart.c	  1346   * FUNCTION:     safety_endinit_set
; ..\cstart.c	  1347   *
; ..\cstart.c	  1348   * DESCRIPTION:  Sets or Clears the ENDINIT bit in the WDTSCON0 register
; ..\cstart.c	  1349   *               in order to enabled or disable the write-protection for
; ..\cstart.c	  1350   *               safety-critical registers protected via the EndInit feature.
; ..\cstart.c	  1351   *
; ..\cstart.c	  1352   *************************************************************************/
; ..\cstart.c	  1353  static void inline safety_endinit_set( _endinit_t endinit_value )
; ..\cstart.c	  1354  {
; ..\cstart.c	  1355          unsigned int wdtscon0;
; ..\cstart.c	  1356  
; ..\cstart.c	  1357          /*
; ..\cstart.c	  1358           * 1st step: Password access (create password and send to WDTSCON0)
; ..\cstart.c	  1359           */
; ..\cstart.c	  1360          wdtscon0 = SCU_WDTSCON0.U;
	fcall	.cocofun_5
	fcall	.cocofun_1
.L176:

; ..\cstart.c	  1361  
; ..\cstart.c	  1362          wdtscon0 &= 0xffffff01;         /* clear WDTLCK, WDTHPW0, WDTHPW1 */
; ..\cstart.c	  1363          wdtscon0 |= 0xf0;               /* set WDTHPW1 to 0xf */
; ..\cstart.c	  1364          wdtscon0 |= 0x1;                /* 1 must be written to ENDINIT for password access
; ..\cstart.c	  1365                                           * (but this will not actually modify the bit) */
; ..\cstart.c	  1366          SCU_WDTSCON0.U = wdtscon0;
; ..\cstart.c	  1367  
; ..\cstart.c	  1368          /*
; ..\cstart.c	  1369           * 2nd step: Modify access, set the bit ENDINIT to 1 or 0 to allow access to
; ..\cstart.c	  1370           *           registers: SCU_WDTSCON1, BTV, BIV, ISP and mod_CLC
; ..\cstart.c	  1371           */
; ..\cstart.c	  1372          wdtscon0 &= 0xfffffff0;         /* clear WDTHPW0, WDTLCK, ENDINIT  */
; ..\cstart.c	  1373          wdtscon0 |= 0x02 | endinit_value;       /* WDTHPW0=0, WDTLCK=1, ENDINIT=0 */
; ..\cstart.c	  1374          __isync();
	isync
.L271:

; ..\cstart.c	  1375          SCU_WDTSCON0.U = wdtscon0;          
	st.w	[a15],d15
.L272:

; ..\cstart.c	  1376          SCU_WDTSCON0.U;                 /* read is required */
	ld.w	d15,[a15]
.L163:
	ret
.L162:
	
___safety_endinit_clear_function_end:
	.size	_safety_endinit_clear,___safety_endinit_clear_function_end-_safety_endinit_clear
.L57:
	; End of function
	
	.sdecl	'.text.cstart..cocofun_5',code,cluster('.cocofun_5')
	.sect	'.text.cstart..cocofun_5'
	.align	2
; Function .cocofun_5
.L16:
.cocofun_5:	.type	func
; Function body .cocofun_5, coco_iter:1
	movh.a	a15,#61443
	lea	a15,[a15]@los(0xf00360f0)
	fret
.L92:
	; End of function
	.sdecl	'.text.cstart._safety_endinit_set',code,cluster('_safety_endinit_set')
	.sect	'.text.cstart._safety_endinit_set'
	.align	2
	
	.global	_safety_endinit_set
; Function _safety_endinit_set
.L18:
_safety_endinit_set:	.type	func
	fcall	.cocofun_5
	fcall	.cocofun_2
.L177:
	isync
.L277:
	st.w	[a15],d15
.L278:
	ld.w	d15,[a15]
.L168:
	ret
.L167:
	
___safety_endinit_set_function_end:
	.size	_safety_endinit_set,___safety_endinit_set_function_end-_safety_endinit_set
.L62:
	; End of function
	
	.sdecl	'.text.libc.reset',code,cluster('_START')
	.sect	'.text.libc.reset'
	.align	2
	
	.global	_START
; Function _START
.L20:
_START:	.type	func
	j	__init_sp
.L171:
	
___START_function_end:
	.size	_START,___START_function_end-_START
.L67:
	; End of function
	
	.sdecl	'.text.cstart.__init_sp',code,cluster('__init_sp')
	.sect	'.text.cstart.__init_sp'
	.align	2
	
; Function __init_sp
.L22:
__init_sp:	.type	func
	movh.a	a15,#@his(_lc_ue_ustack)
	lea	a15,[a15]@los(_lc_ue_ustack)
	mov.d	d15,a15
.L209:
	insert	d15,d15,#0,#0,#3
.L210:
	mov.a	a15,d15
.L211:
	mov.aa	a10,a15
.L212:
	j	_start
.L93:
	
____init_sp_function_end:
	.size	__init_sp,____init_sp_function_end-__init_sp
.L37:
	; End of function
	
	.sdecl	'.text.cstart._start',code,cluster('_start')
	.sect	'.text.cstart._start'
	.align	2
	
; Function _start
.L24:
_start:	.type	func
	dsync
.L96:
	mov	d15,#2432
.L217:
	mtcr	#65028,d15
	isync
.L97:
	mfcr	d15,#65024
.L218:
	insert	d15,d15,#0,#0,#20
.L178:
	mtcr	#65024,d15
	isync
.L102:
	fcall	.cocofun_5
.L179:
	fcall	.cocofun_1
.L181:
	isync
.L219:
	st.w	[a15],d15
.L220:
	ld.w	d15,[a15]
.L103:
	movh.a	a2,#61443
	ld.w	d15,[a2]@los(0xf00360f4)
.L221:
	or	d15,#8
	st.w	[a2]@los(0xf00360f4),d15
.L108:
	fcall	.cocofun_2
.L182:
	isync
.L222:
	st.w	[a15],d15
.L223:
	ld.w	d15,[a15]
.L109:
	fcall	.cocofun_1
.L183:
	isync
.L224:
	st.w	[a15],d15
.L111:
	mov.aa	a4,a2
.L113:
	ld.w	d15,[a15]
.L114:
	lea	a4,[a4]@los(0xf0036100)
	fcall	.cocofun_3
.L225:
	isync
.L185:
	st.w	[a4],d15
.L226:
	ld.w	d15,[a4]
.L121:
	ld.w	d15,[a2]@los(0xf0036104)
.L227:
	or	d15,#8
	st.w	[a2]@los(0xf0036104),d15
.L123:
	fcall	.cocofun_4
.L228:
	isync
.L187:
	st.w	[a4],d15
.L229:
	ld.w	d15,[a4]
.L124:
	fcall	.cocofun_3
.L188:
	isync
.L230:
	st.w	[a4],d15
.L127:
	movh.a	a2,#@his(_lc_u_int_tab)
	lea	a2,[a2]@los(_lc_u_int_tab)
.L129:
	ld.w	d15,[a4]
.L130:
	mov.d	d15,a2
.L231:
	mtcr	#65056,d15
	isync
.L132:
	movh.a	a2,#@his(_lc_ue_istack)
	lea	a2,[a2]@los(_lc_ue_istack)
	mov.d	d15,a2
.L232:
	insert	d15,d15,#0,#0,#3
.L233:
	mtcr	#65064,d15
	isync
.L234:
	mov	d15,#0
.L235:
	mtcr	#37388,d15
	isync
.L236:
	mtcr	#36928,d15
	isync
.L237:
	movh.a	a2,#61466
	st.w	[a2]@los(0xf019fd00),d15
.L133:
	fcall	.cocofun_4
.L189:
	isync
.L238:
	st.w	[a4],d15
.L239:
	ld.w	d15,[a4]
.L134:
	fcall	.cocofun_2
.L190:
	isync
.L240:
	st.w	[a15],d15
.L241:
	ld.w	d15,[a15]
.L136:
	movh.a	a15,#@his(_SMALL_DATA_)
	lea	a15,[a15]@los(_SMALL_DATA_)
.L242:
	mov.aa	a0,a15
.L138:
	movh.a	a15,#@his(_LITERAL_DATA_)
	lea	a15,[a15]@los(_LITERAL_DATA_)
.L243:
	mov.aa	a1,a15
.L139:
	movh.a	a15,#@his(_A8_DATA_)
	lea	a15,[a15]@los(_A8_DATA_)
.L244:
	mov.aa	a8,a15
.L140:
	movh.a	a15,#@his(_A9_DATA_)
	lea	a15,[a15]@los(_A9_DATA_)
.L245:
	mov.aa	a9,a15
.L141:
	mov	d0,#0
.L191:
	mov	d15,#1
	movh.a	a15,#@his(_lc_ub_csa_01)
.L193:
	lea	a15,[a15]@los(_lc_ub_csa_01)
.L246:
	movh.a	a2,#@his(_lc_ue_csa_01)
	lea	a2,[a2]@los(_lc_ue_csa_01)
.L247:
	sub.a	a2,a2,a15
	mov.d	d1,a2
.L194:
	sha	d1,#-6
.L248:
	mov	d2,d0
	j	.L2
.L3:
	mov.aa	a2,a15
.L196:
	mov.d	d3,a2
.L197:
	st.w	[a2],d0
.L249:
	sh	d0,d3,#-28
	lea	a15,[a15]64
.L192:
	extr.u	d3,d3,#6,#16
.L198:
	sh	d0,d0,#16
.L199:
	or	d0,d3
.L200:
	jeq	d15,#0,.L4
.L250:
	mov	d15,#0
.L251:
	mtcr	#65084,d0
	isync
.L4:
	add	d2,#1
.L2:
	jlt	d2,d1,.L3
.L252:
	mtcr	#65080,d0
	isync
.L253:
	call	_c_init
.L195:
	mov	d4,#0
	mov.a	a4,#0
	call	main
.L254:
	mov	d4,d2
	j	exit
.L94:
	
___start_function_end:
	.size	_start,___start_function_end-_start
.L42:
	; End of function
	
	.sdecl	'.text.cstart..cocofun_4',code,cluster('.cocofun_4')
	.sect	'.text.cstart..cocofun_4'
	.align	2
; Function .cocofun_4
.L26:
.cocofun_4:	.type	func
; Function body .cocofun_4, coco_iter:0
	ld.w	d15,[a4]
.L304:
	insert	d15,d15,#0,#1,#7
.L186:
	or	d15,#241
	st.w	[a4],d15
.L305:
	insert	d15,d15,#3,#0,#4
	fret
.L87:
	; End of function
	.sdecl	'.text.cstart..cocofun_3',code,cluster('.cocofun_3')
	.sect	'.text.cstart..cocofun_3'
	.align	2
; Function .cocofun_3
.L28:
.cocofun_3:	.type	func
; Function body .cocofun_3, coco_iter:0
	ld.w	d15,[a4]
.L298:
	insert	d15,d15,#0,#1,#7
.L184:
	or	d15,#241
	st.w	[a4],d15
.L299:
	insert	d15,d15,#2,#0,#4
	fret
.L82:
	; End of function
	.calls	'_START','__init_sp'
	.calls	'__init_sp','_start'
	.calls	'_start','_c_init'
	.calls	'_start','main'
	.calls	'_start','exit'
	.calls	'_endinit_clear','.cocofun_1'
	.calls	'_endinit_set','.cocofun_2'
	.calls	'_safety_endinit_clear','.cocofun_5'
	.calls	'_safety_endinit_clear','.cocofun_1'
	.calls	'_safety_endinit_set','.cocofun_5'
	.calls	'_safety_endinit_set','.cocofun_2'
	.calls	'_start','.cocofun_5'
	.calls	'_start','.cocofun_1'
	.calls	'_start','.cocofun_2'
	.calls	'_start','.cocofun_3'
	.calls	'_start','.cocofun_4'
	.calls	'_endinit_clear','',0
	.calls	'.cocofun_1','',0
	.calls	'_endinit_set','',0
	.calls	'.cocofun_2','',0
	.calls	'_safety_endinit_clear','',0
	.calls	'.cocofun_5','',0
	.calls	'_safety_endinit_set','',0
	.calls	'_START','',0
	.calls	'__init_sp','',0
	.calls	'_start','',0
	.calls	'.cocofun_4','',0
	.weak	exit
	.extern	exit
	.extern	_Exit
	.extern	_lc_ue_ustack
	.extern	_lc_ue_istack
	.extern	_lc_u_int_tab
	.extern	_SMALL_DATA_
	.extern	_LITERAL_DATA_
	.extern	_A8_DATA_
	.extern	_A9_DATA_
	.extern	_c_init
	.extern	main
	.extern	_lc_ub_csa_01
	.extern	_lc_ue_csa_01
	.calls	'.cocofun_3','',0
	.sdecl	'.debug_info',debug
	.sect	'.debug_info'
.L30:
	.word	829
	.half	3
	.word	.L31
	.byte	4
.L29:
	.byte	1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L32
	.byte	2,1,73,9,1,3
	.byte	'_ENDINIT_DISABLE',0,0,3
	.byte	'_ENDINIT_ENABLE',0,1,0
.L116:
	.byte	4
	.byte	'endinit_set',0,3,1,154,10,20,1,1
.L117:
	.byte	5
	.byte	'endinit_value',0,1,154,10,44
	.word	134
.L119:
	.byte	6,0
.L101:
	.byte	4
	.byte	'safety_endinit_set',0,3,1,201,10,20,1,1
.L104:
	.byte	5
	.byte	'endinit_value',0,1,201,10,51
	.word	134
.L106:
	.byte	6,0
.L95:
	.byte	4
	.byte	'reset_psw',0,3,1,255,1,20,1,1
.L98:
	.byte	6,0
.L142:
	.byte	7
	.byte	'int',0,4,5,8
	.byte	'__mtcr',0,1,1,1,1,9
	.word	294
	.byte	9
	.word	294
	.byte	0,10
	.word	294
	.byte	11
	.byte	'__mfcr',0
	.word	324
	.byte	1,1,1,1,9
	.word	294
	.byte	0,12
	.byte	'__isync',0,1,1,1,1,12
	.byte	'__dsync',0,1,1,1,1,13
	.byte	'void',0,14
	.word	377
	.byte	8
	.byte	'__set_sp',0,1,1,1,1,9
	.word	383
	.byte	0,15
	.byte	'exit',0,2,102,33,1,1,1,1,16,2,102,44
	.word	294
	.byte	0,17
	.byte	'_c_init',0,1,49,13,1,1,1,1
.L99:
	.byte	7
	.byte	'unsigned int',0,4,7
.L145:
	.byte	14
	.word	294
.L150:
	.byte	7
	.byte	'_Bool',0,1,2,18
	.word	177
	.byte	19
	.word	197
	.byte	6,0,18
	.word	222
	.byte	19
	.word	249
	.byte	6,0,18
	.word	274
	.byte	6,0,7
	.byte	'short int',0,2,5,20
	.byte	'__wchar_t',0,1,1,1
	.word	507
	.byte	20
	.byte	'__size_t',0,1,1,1
	.word	446
	.byte	21,1,14
	.word	555
	.byte	20
	.byte	'__codeptr',0,1,1,1
	.word	557
	.byte	22
	.word	377
	.byte	23,0,24
	.byte	'_lc_ue_ustack',0,1,38,19
	.word	580
	.byte	1,1,24
	.byte	'_lc_ue_istack',0,1,39,19
	.word	580
	.byte	1,1,24
	.byte	'_lc_u_int_tab',0,1,40,19
	.word	580
	.byte	1,1,24
	.byte	'_SMALL_DATA_',0,1,42,19
	.word	580
	.byte	1,1,24
	.byte	'_LITERAL_DATA_',0,1,43,19
	.word	580
	.byte	1,1,24
	.byte	'_A8_DATA_',0,1,44,19
	.word	580
	.byte	1,1,24
	.byte	'_A9_DATA_',0,1,45,19
	.word	580
	.byte	1,1,20
	.byte	'_endinit_t',0,1,77,9
	.word	134
	.byte	25,64
	.word	294
	.byte	26,15,0,22
	.word	766
	.byte	23,0,24
	.byte	'_lc_ub_csa_01',0,1,242,8,12
	.word	775
	.byte	1,1,24
	.byte	'_lc_ue_csa_01',0,1,243,8,12
	.word	775
	.byte	1,1,0
	.sdecl	'.debug_abbrev',debug
	.sect	'.debug_abbrev'
.L31:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,16,6,0,0,2,4,1,58,15,59,15,57,15,11,15,0,0,3,40,0,3,8,28,13,0,0,4
	.byte	46,1,3,8,32,13,58,15,59,15,57,15,54,15,39,12,0,0,5,5,0,3,8,58,15,59,15,57,15,73,19,0,0,6,11,0,0,0,7,36
	.byte	0,3,8,11,15,62,15,0,0,8,46,1,3,8,54,15,39,12,63,12,60,12,0,0,9,5,0,73,19,0,0,10,53,0,73,19,0,0,11,46,1
	.byte	3,8,73,19,54,15,39,12,63,12,60,12,0,0,12,46,0,3,8,54,15,39,12,63,12,60,12,0,0,13,59,0,3,8,0,0,14,15,0
	.byte	73,19,0,0,15,46,1,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,16,5,0,58,15,59,15,57,15,73,19,0,0
	.byte	17,46,0,3,8,58,15,59,15,57,15,54,15,39,12,63,12,60,12,0,0,18,46,1,49,19,0,0,19,5,0,49,19,0,0,20,22,0,3
	.byte	8,58,15,59,15,57,15,73,19,0,0,21,21,0,54,15,0,0,22,1,1,73,19,0,0,23,33,0,0,0,24,52,0,3,8,58,15,59,15,57
	.byte	15,73,19,63,12,60,12,0,0,25,1,1,11,15,73,19,0,0,26,33,0,47,15,0,0,0
	.sdecl	'.debug_line',debug
	.sect	'.debug_line'
.L32:
	.word	.L202-.L201
.L201:
	.half	3
	.word	.L204-.L203
.L203:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1
	.byte	'C:\\TASKING\\TriCore v6.2r2\\ctc\\include\\',0,0
	.byte	'..\\cstart.c',0,0,0,0
	.byte	'stdlib.h',0,1,0,0,0
.L204:
.L202:
	.sdecl	'.debug_info',debug,cluster('__init_sp')
	.sect	'.debug_info'
.L33:
	.word	179
	.half	3
	.word	.L34
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L36,.L35
	.byte	2
	.word	.L29
	.byte	3
	.byte	'__init_sp',0,1,215,1,48,1,1
	.word	.L22,.L93,.L21
	.byte	4
	.word	.L22,.L93
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('__init_sp')
	.sect	'.debug_abbrev'
.L34:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('__init_sp')
	.sect	'.debug_line'
.L35:
	.word	.L206-.L205
.L205:
	.half	3
	.word	.L208-.L207
.L207:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L208:
	.byte	5,45,7,0,5,2
	.word	.L22
	.byte	3,247,1,1,5,60,9
	.half	.L209-.L22
	.byte	1,5,21,9
	.half	.L210-.L209
	.byte	1,5,17,9
	.half	.L211-.L210
	.byte	3,2,1,5,15,9
	.half	.L212-.L211
	.byte	3,2,1,5,1,7,9
	.half	.L37-.L212
	.byte	3,1,0,1,1
.L206:
	.sdecl	'.debug_ranges',debug,cluster('__init_sp')
	.sect	'.debug_ranges'
.L36:
	.word	-1,.L22,0,.L37-.L22,0,0
	.sdecl	'.debug_info',debug,cluster('_start')
	.sect	'.debug_info'
.L38:
	.word	955
	.half	3
	.word	.L39
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L41,.L40
	.byte	2
	.word	.L29
	.byte	3
	.byte	'_start',0,1,145,2,48,1,1
	.word	.L24,.L94,.L23
	.byte	4
	.word	.L24,.L94
	.byte	5
	.word	.L95,.L96,.L97
	.byte	6
	.word	.L98,.L96,.L97
	.byte	0,4
	.word	.L97,.L94
	.byte	7
	.byte	'pcxi',0,1,137,3,22
	.word	.L99,.L100
	.byte	5
	.word	.L101,.L102,.L103
	.byte	8
	.word	.L104,.L105
	.byte	9
	.word	.L106,.L102,.L103
	.byte	7
	.byte	'wdtscon0',0,1,203,10,22
	.word	.L99,.L107
	.byte	0,0,5
	.word	.L101,.L108,.L109
	.byte	8
	.word	.L104,.L105
	.byte	9
	.word	.L106,.L108,.L109
	.byte	7
	.byte	'wdtscon0',0,1,203,10,22
	.word	.L99,.L110
	.byte	0,0,5
	.word	.L101,.L109,.L111
	.byte	8
	.word	.L104,.L105
	.byte	10
	.word	.L106,.L112
	.byte	7
	.byte	'wdtscon0',0,1,203,10,22
	.word	.L99,.L115
	.byte	0,0,5
	.word	.L116,.L111,.L113
	.byte	8
	.word	.L117,.L118
	.byte	10
	.word	.L119,.L120
	.byte	7
	.byte	'wdt_con0',0,1,156,10,22
	.word	.L99,.L122
	.byte	0,0,5
	.word	.L101,.L113,.L114
	.byte	8
	.word	.L104,.L105
	.byte	0,5
	.word	.L116,.L114,.L121
	.byte	8
	.word	.L117,.L118
	.byte	0,5
	.word	.L116,.L123,.L124
	.byte	8
	.word	.L117,.L118
	.byte	10
	.word	.L119,.L125
	.byte	7
	.byte	'wdt_con0',0,1,156,10,22
	.word	.L99,.L126
	.byte	0,0,5
	.word	.L116,.L124,.L127
	.byte	8
	.word	.L117,.L118
	.byte	10
	.word	.L119,.L128
	.byte	7
	.byte	'wdt_con0',0,1,156,10,22
	.word	.L99,.L131
	.byte	0,0,5
	.word	.L116,.L129,.L130
	.byte	8
	.word	.L117,.L118
	.byte	0,4
	.word	.L132,.L94
	.byte	5
	.word	.L116,.L133,.L134
	.byte	8
	.word	.L117,.L118
	.byte	9
	.word	.L119,.L133,.L134
	.byte	7
	.byte	'wdt_con0',0,1,156,10,22
	.word	.L99,.L135
	.byte	0,0,5
	.word	.L101,.L134,.L136
	.byte	8
	.word	.L104,.L105
	.byte	9
	.word	.L106,.L134,.L136
	.byte	7
	.byte	'wdtscon0',0,1,203,10,22
	.word	.L99,.L137
	.byte	0,0,4
	.word	.L136,.L94
	.byte	4
	.word	.L138,.L94
	.byte	4
	.word	.L139,.L94
	.byte	4
	.word	.L140,.L94
	.byte	4
	.word	.L141,.L94
	.byte	7
	.byte	'k',0,1,130,9,17
	.word	.L142,.L143
	.byte	7
	.byte	'no_of_csas',0,1,131,9,14
	.word	.L142,.L144
	.byte	7
	.byte	'csa',0,1,132,9,15
	.word	.L145,.L146
	.byte	7
	.byte	'seg_nr',0,1,133,9,23
	.word	.L99,.L147
	.byte	7
	.byte	'seg_idx',0,1,133,9,31
	.word	.L99,.L148
	.byte	7
	.byte	'pcxi_val',0,1,133,9,40
	.word	.L99,.L149
	.byte	7
	.byte	'first',0,1,134,9,15
	.word	.L150,.L151
	.byte	0,0,0,0,0,0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('_start')
	.sect	'.debug_abbrev'
.L39:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,29,1,49,16,17,1,18,1,0,0,6,11,0,49,16,17,1,18,1,0,0,7
	.byte	52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,8,5,0,49,16,2,6,0,0,9,11,1,49,16,17,1,18,1,0,0,10,11,1,49,16
	.byte	85,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('_start')
	.sect	'.debug_line'
.L40:
	.word	.L214-.L213
.L213:
	.half	3
	.word	.L216-.L215
.L215:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L216:
	.byte	5,16,7,0,5,2
	.word	.L24
	.byte	3,130,3,1,5,21,9
	.half	.L96-.L24
	.byte	3,135,127,1,5,15,9
	.half	.L217-.L96
	.byte	1,5,35,9
	.half	.L97-.L217
	.byte	3,255,0,1,5,14,9
	.half	.L218-.L97
	.byte	3,1,1,5,15,9
	.half	.L178-.L218
	.byte	3,1,1,5,32,9
	.half	.L102-.L178
	.byte	3,197,7,1,5,16,9
	.half	.L181-.L102
	.byte	3,14,1,5,24,9
	.half	.L219-.L181
	.byte	3,1,1,5,21,9
	.half	.L220-.L219
	.byte	3,1,1,9
	.half	.L103-.L220
	.byte	3,229,120,1,5,24,9
	.half	.L221-.L103
	.byte	1,5,32,9
	.half	.L108-.L221
	.byte	3,139,7,1,5,16,9
	.half	.L182-.L108
	.byte	3,14,1,5,24,9
	.half	.L222-.L182
	.byte	3,1,1,5,21,9
	.half	.L223-.L222
	.byte	3,1,1,5,32,9
	.half	.L109-.L223
	.byte	3,112,1,5,16,9
	.half	.L183-.L109
	.byte	3,14,1,5,24,9
	.half	.L224-.L183
	.byte	3,1,1,5,28,9
	.half	.L111-.L224
	.byte	3,69,1,5,21,9
	.half	.L113-.L111
	.byte	3,60,1,5,28,9
	.half	.L114-.L113
	.byte	3,68,1,5,16,9
	.half	.L225-.L114
	.byte	3,22,1,5,20,9
	.half	.L185-.L225
	.byte	3,1,1,5,17,9
	.half	.L226-.L185
	.byte	3,1,1,9
	.half	.L121-.L226
	.byte	3,156,121,1,5,20,9
	.half	.L227-.L121
	.byte	1,5,28,9
	.half	.L123-.L227
	.byte	3,204,6,1,5,16,9
	.half	.L228-.L123
	.byte	3,22,1,5,20,9
	.half	.L187-.L228
	.byte	3,1,1,5,17,9
	.half	.L229-.L187
	.byte	3,1,1,5,28,9
	.half	.L124-.L229
	.byte	3,104,1,5,16,9
	.half	.L188-.L124
	.byte	3,22,1,5,20,9
	.half	.L230-.L188
	.byte	3,1,1,5,36,9
	.half	.L127-.L230
	.byte	3,204,121,1,5,17,9
	.half	.L129-.L127
	.byte	3,181,6,1,5,36,9
	.half	.L130-.L129
	.byte	3,203,121,1,5,15,9
	.half	.L231-.L130
	.byte	1,5,43,9
	.half	.L132-.L231
	.byte	3,11,1,5,58,9
	.half	.L232-.L132
	.byte	1,5,15,9
	.half	.L233-.L232
	.byte	3,1,1,5,40,9
	.half	.L234-.L233
	.byte	3,55,1,5,32,9
	.half	.L235-.L234
	.byte	1,9
	.half	.L236-.L235
	.byte	3,7,1,5,39,9
	.half	.L237-.L236
	.byte	3,144,2,1,5,28,9
	.half	.L133-.L237
	.byte	3,195,3,1,5,16,9
	.half	.L189-.L133
	.byte	3,22,1,5,20,9
	.half	.L238-.L189
	.byte	3,1,1,5,17,9
	.half	.L239-.L238
	.byte	3,1,1,5,32,9
	.half	.L134-.L239
	.byte	3,20,1,5,16,9
	.half	.L190-.L134
	.byte	3,14,1,5,24,9
	.half	.L240-.L190
	.byte	3,1,1,5,21,9
	.half	.L241-.L240
	.byte	3,1,1,9
	.half	.L136-.L241
	.byte	3,248,125,1,5,9,9
	.half	.L242-.L136
	.byte	3,1,1,5,21,9
	.half	.L138-.L242
	.byte	3,2,1,5,9,9
	.half	.L243-.L138
	.byte	3,1,1,5,21,9
	.half	.L139-.L243
	.byte	3,10,1,5,9,9
	.half	.L244-.L139
	.byte	3,1,1,5,21,9
	.half	.L140-.L244
	.byte	3,2,1,5,9,9
	.half	.L245-.L140
	.byte	3,1,1,5,48,9
	.half	.L141-.L245
	.byte	3,27,1,5,20,9
	.half	.L191-.L141
	.byte	3,1,1,5,53,3,110,1,9
	.half	.L246-.L191
	.byte	3,1,1,5,46,9
	.half	.L247-.L246
	.byte	3,22,1,5,23,9
	.half	.L248-.L247
	.byte	3,2,1,5,41,1,5,29,9
	.half	.L3-.L248
	.byte	3,2,1,5,51,9
	.half	.L196-.L3
	.byte	3,4,1,5,30,9
	.half	.L197-.L196
	.byte	3,126,1,5,55,9
	.half	.L249-.L197
	.byte	3,2,1,5,44,3,122,1,5,61,9
	.half	.L192-.L249
	.byte	3,7,1,5,69,9
	.half	.L198-.L192
	.byte	3,127,1,5,43,9
	.half	.L199-.L198
	.byte	3,2,1,5,25,9
	.half	.L200-.L199
	.byte	3,1,1,5,39,7,9
	.half	.L250-.L200
	.byte	3,2,1,9
	.half	.L251-.L250
	.byte	3,1,1,5,44,9
	.half	.L4-.L251
	.byte	3,116,1,5,41,9
	.half	.L2-.L4
	.byte	1,5,23,7,9
	.half	.L252-.L2
	.byte	3,15,1,5,16,9
	.half	.L253-.L252
	.byte	3,16,1,5,21,9
	.half	.L195-.L253
	.byte	3,193,0,1,5,24,1,5,19,9
	.half	.L254-.L195
	.byte	1,5,1,9
	.half	.L42-.L254
	.byte	3,33,0,1,1
.L214:
	.sdecl	'.debug_ranges',debug,cluster('_start')
	.sect	'.debug_ranges'
.L41:
	.word	-1,.L24,0,.L42-.L24,0,0
.L112:
	.word	-1,.L24,.L109-.L24,.L111-.L24,.L113-.L24,.L114-.L24,0,0
.L120:
	.word	-1,.L24,.L111-.L24,.L113-.L24,.L114-.L24,.L121-.L24,-1,.L28,0,.L82-.L28,0,0
.L125:
	.word	-1,.L24,.L123-.L24,.L124-.L24,-1,.L26,0,.L87-.L26,0,0
.L128:
	.word	-1,.L24,.L124-.L24,.L127-.L24,.L129-.L24,.L130-.L24,0,0
	.sdecl	'.debug_info',debug,cluster('_endinit_clear')
	.sect	'.debug_info'
.L43:
	.word	240
	.half	3
	.word	.L44
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L46,.L45
	.byte	2
	.word	.L29
	.byte	3
	.byte	'_endinit_clear',0,1,91,13,1,1,1
	.word	.L6,.L152,.L5
	.byte	4
	.word	.L6,.L152
	.byte	5
	.word	.L116,.L6,.L153
	.byte	6
	.word	.L117,.L154
	.byte	7
	.word	.L119,.L155
	.byte	8
	.byte	'wdt_con0',0,1,156,10,22
	.word	.L99,.L156
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('_endinit_clear')
	.sect	'.debug_abbrev'
.L44:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,29,1,49,16,17,1,18,1,0,0,6,5,0,49,16,2,6,0,0,7,11
	.byte	1,49,16,85,6,0,0,8,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('_endinit_clear')
	.sect	'.debug_line'
.L45:
	.word	.L256-.L255
.L255:
	.half	3
	.word	.L258-.L257
.L257:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L258:
	.byte	5,28,7,0,5,2
	.word	.L6
	.byte	3,163,10,1,5,16,9
	.half	.L259-.L6
	.byte	3,22,1,5,20,9
	.half	.L173-.L259
	.byte	3,1,1,5,17,9
	.half	.L260-.L173
	.byte	3,1,1,5,67,9
	.half	.L153-.L260
	.byte	3,159,118,1,7,9
	.half	.L47-.L153
	.byte	0,1,1
.L256:
	.sdecl	'.debug_ranges',debug,cluster('_endinit_clear')
	.sect	'.debug_ranges'
.L46:
	.word	-1,.L6,0,.L47-.L6,0,0
.L155:
	.word	-1,.L6,0,.L153-.L6,-1,.L8,0,.L72-.L8,0,0
	.sdecl	'.debug_info',debug,cluster('_endinit_set')
	.sect	'.debug_info'
.L48:
	.word	238
	.half	3
	.word	.L49
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L51,.L50
	.byte	2
	.word	.L29
	.byte	3
	.byte	'_endinit_set',0,1,92,13,1,1,1
	.word	.L10,.L157,.L9
	.byte	4
	.word	.L10,.L157
	.byte	5
	.word	.L116,.L10,.L158
	.byte	6
	.word	.L117,.L159
	.byte	7
	.word	.L119,.L160
	.byte	8
	.byte	'wdt_con0',0,1,156,10,22
	.word	.L99,.L161
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('_endinit_set')
	.sect	'.debug_abbrev'
.L49:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,29,1,49,16,17,1,18,1,0,0,6,5,0,49,16,2,6,0,0,7,11
	.byte	1,49,16,85,6,0,0,8,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('_endinit_set')
	.sect	'.debug_line'
.L50:
	.word	.L262-.L261
.L261:
	.half	3
	.word	.L264-.L263
.L263:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L264:
	.byte	5,28,7,0,5,2
	.word	.L10
	.byte	3,163,10,1,5,16,9
	.half	.L265-.L10
	.byte	3,22,1,5,20,9
	.half	.L175-.L265
	.byte	3,1,1,5,17,9
	.half	.L266-.L175
	.byte	3,1,1,5,66,9
	.half	.L158-.L266
	.byte	3,160,118,1,7,9
	.half	.L52-.L158
	.byte	0,1,1
.L262:
	.sdecl	'.debug_ranges',debug,cluster('_endinit_set')
	.sect	'.debug_ranges'
.L51:
	.word	-1,.L10,0,.L52-.L10,0,0
.L160:
	.word	-1,.L10,0,.L158-.L10,-1,.L12,0,.L77-.L12,0,0
	.sdecl	'.debug_info',debug,cluster('_safety_endinit_clear')
	.sect	'.debug_info'
.L53:
	.word	247
	.half	3
	.word	.L54
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L56,.L55
	.byte	2
	.word	.L29
	.byte	3
	.byte	'_safety_endinit_clear',0,1,116,13,1,1,1
	.word	.L14,.L162,.L13
	.byte	4
	.word	.L14,.L162
	.byte	5
	.word	.L101,.L14,.L163
	.byte	6
	.word	.L104,.L164
	.byte	7
	.word	.L106,.L165
	.byte	8
	.byte	'wdtscon0',0,1,203,10,22
	.word	.L99,.L166
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('_safety_endinit_clear')
	.sect	'.debug_abbrev'
.L54:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,29,1,49,16,17,1,18,1,0,0,6,5,0,49,16,2,6,0,0,7,11
	.byte	1,49,16,85,6,0,0,8,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('_safety_endinit_clear')
	.sect	'.debug_line'
.L55:
	.word	.L268-.L267
.L267:
	.half	3
	.word	.L270-.L269
.L269:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L270:
	.byte	5,32,7,0,5,2
	.word	.L14
	.byte	3,207,10,1,5,16,9
	.half	.L176-.L14
	.byte	3,14,1,5,24,9
	.half	.L271-.L176
	.byte	3,1,1,5,21,9
	.half	.L272-.L271
	.byte	3,1,1,5,81,9
	.half	.L163-.L272
	.byte	3,148,118,1,7,9
	.half	.L57-.L163
	.byte	0,1,1
.L268:
	.sdecl	'.debug_ranges',debug,cluster('_safety_endinit_clear')
	.sect	'.debug_ranges'
.L56:
	.word	-1,.L14,0,.L57-.L14,0,0
.L165:
	.word	-1,.L14,0,.L163-.L14,-1,.L16,0,.L92-.L16,0,0
	.sdecl	'.debug_info',debug,cluster('_safety_endinit_set')
	.sect	'.debug_info'
.L58:
	.word	249
	.half	3
	.word	.L59
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L61,.L60
	.byte	2
	.word	.L29
	.byte	3
	.byte	'_safety_endinit_set',0,1,117,13,1,1,1
	.word	.L18,.L167,.L17
	.byte	4
	.word	.L18,.L167
	.byte	5
	.word	.L101,.L18,.L168
	.byte	6
	.word	.L104,.L169
	.byte	7
	.word	.L106,.L18,.L168
	.byte	8
	.byte	'wdtscon0',0,1,203,10,22
	.word	.L99,.L170
	.byte	0,0,0,0,0
	.sdecl	'.debug_abbrev',debug,cluster('_safety_endinit_set')
	.sect	'.debug_abbrev'
.L59:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,1,17,1,18,1,0,0,5,29,1,49,16,17,1,18,1,0,0,6,5,0,49,16,2,6,0,0,7,11
	.byte	1,49,16,17,1,18,1,0,0,8,52,0,3,8,58,15,59,15,57,15,73,16,2,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('_safety_endinit_set')
	.sect	'.debug_line'
.L60:
	.word	.L274-.L273
.L273:
	.half	3
	.word	.L276-.L275
.L275:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L276:
	.byte	5,32,7,0,5,2
	.word	.L18
	.byte	3,207,10,1,5,16,9
	.half	.L177-.L18
	.byte	3,14,1,5,24,9
	.half	.L277-.L177
	.byte	3,1,1,5,21,9
	.half	.L278-.L277
	.byte	3,1,1,5,80,9
	.half	.L168-.L278
	.byte	3,149,118,1,7,9
	.half	.L62-.L168
	.byte	0,1,1
.L274:
	.sdecl	'.debug_ranges',debug,cluster('_safety_endinit_set')
	.sect	'.debug_ranges'
.L61:
	.word	-1,.L18,0,.L62-.L18,0,0
	.sdecl	'.debug_info',debug,cluster('_START')
	.sect	'.debug_info'
.L63:
	.word	177
	.half	3
	.word	.L64
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L66,.L65
	.byte	2
	.word	.L29
	.byte	3
	.byte	'_START',0,1,193,1,6,1,1,1
	.word	.L20,.L171,.L19
	.byte	4
	.word	.L20,.L171
	.byte	0,0
	.sdecl	'.debug_abbrev',debug,cluster('_START')
	.sect	'.debug_abbrev'
.L64:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,1,3,8,58,15,59,15,57,15,54,15
	.byte	39,12,63,12,17,1,18,1,64,6,0,0,4,11,0,17,1,18,1,0,0,0
	.sdecl	'.debug_line',debug,cluster('_START')
	.sect	'.debug_line'
.L65:
	.word	.L280-.L279
.L279:
	.half	3
	.word	.L282-.L281
.L281:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L282:
	.byte	5,18,7,0,5,2
	.word	.L20
	.byte	3,194,1,1,5,1,7,9
	.half	.L67-.L20
	.byte	3,1,0,1,1
.L280:
	.sdecl	'.debug_ranges',debug,cluster('_START')
	.sect	'.debug_ranges'
.L66:
	.word	-1,.L20,0,.L67-.L20,0,0
	.sdecl	'.debug_info',debug,cluster('.cocofun_1')
	.sect	'.debug_info'
.L68:
	.word	168
	.half	3
	.word	.L69
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L71,.L70
	.byte	2
	.word	.L29
	.byte	3
	.byte	'.cocofun_1',0,1,91,13,1
	.word	.L8,.L72,.L7
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('.cocofun_1')
	.sect	'.debug_abbrev'
.L69:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,0,3,8,58,15,59,15,57,15,54,15
	.byte	17,1,18,1,64,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('.cocofun_1')
	.sect	'.debug_line'
.L70:
	.word	.L284-.L283
.L283:
	.half	3
	.word	.L286-.L285
.L285:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L286:
	.byte	5,28,7,0,5,2
	.word	.L8
	.byte	3,163,10,1,5,18,9
	.half	.L180-.L8
	.byte	3,5,1,5,20,9
	.half	.L172-.L180
	.byte	3,9,1,5,18,9
	.half	.L287-.L172
	.byte	3,7,1,9
	.half	.L72-.L287
	.byte	0,1,1,5,32,0,5,2
	.word	.L8
	.byte	3,207,10,1,5,18,9
	.half	.L180-.L8
	.byte	3,2,1,5,24,9
	.half	.L172-.L180
	.byte	3,4,1,5,18,9
	.half	.L287-.L172
	.byte	3,7,1,3,92,1,7,9
	.half	.L72-.L287
	.byte	0,1,1,5,32,0,5,2
	.word	.L8
	.byte	3,207,10,1,5,18,9
	.half	.L180-.L8
	.byte	3,2,1,5,24,9
	.half	.L172-.L180
	.byte	3,4,1,5,18,9
	.half	.L287-.L172
	.byte	3,7,1,3,92,1,7,9
	.half	.L72-.L287
	.byte	0,1,1,5,32,0,5,2
	.word	.L8
	.byte	3,207,10,1,5,18,9
	.half	.L180-.L8
	.byte	3,2,1,5,24,9
	.half	.L172-.L180
	.byte	3,4,1,5,18,9
	.half	.L287-.L172
	.byte	3,7,1,3,92,1,7,9
	.half	.L72-.L287
	.byte	0,1,1
.L284:
	.sdecl	'.debug_ranges',debug,cluster('.cocofun_1')
	.sect	'.debug_ranges'
.L71:
	.word	-1,.L8,0,.L72-.L8,0,0
	.sdecl	'.debug_info',debug,cluster('.cocofun_2')
	.sect	'.debug_info'
.L73:
	.word	168
	.half	3
	.word	.L74
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L76,.L75
	.byte	2
	.word	.L29
	.byte	3
	.byte	'.cocofun_2',0,1,92,13,1
	.word	.L12,.L77,.L11
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('.cocofun_2')
	.sect	'.debug_abbrev'
.L74:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,0,3,8,58,15,59,15,57,15,54,15
	.byte	17,1,18,1,64,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('.cocofun_2')
	.sect	'.debug_line'
.L75:
	.word	.L289-.L288
.L288:
	.half	3
	.word	.L291-.L290
.L290:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L291:
	.byte	5,28,7,0,5,2
	.word	.L12
	.byte	3,163,10,1,5,18,9
	.half	.L292-.L12
	.byte	3,5,1,5,20,9
	.half	.L174-.L292
	.byte	3,9,1,5,18,9
	.half	.L293-.L174
	.byte	3,7,1,9
	.half	.L77-.L293
	.byte	0,1,1,5,32,0,5,2
	.word	.L12
	.byte	3,207,10,1,5,18,9
	.half	.L292-.L12
	.byte	3,2,1,5,24,9
	.half	.L174-.L292
	.byte	3,4,1,5,18,9
	.half	.L293-.L174
	.byte	3,7,1,3,92,1,7,9
	.half	.L77-.L293
	.byte	0,1,1,5,32,0,5,2
	.word	.L12
	.byte	3,207,10,1,5,18,9
	.half	.L292-.L12
	.byte	3,2,1,5,24,9
	.half	.L174-.L292
	.byte	3,4,1,5,18,9
	.half	.L293-.L174
	.byte	3,7,1,3,92,1,7,9
	.half	.L77-.L293
	.byte	0,1,1,5,32,0,5,2
	.word	.L12
	.byte	3,207,10,1,5,18,9
	.half	.L292-.L12
	.byte	3,2,1,5,24,9
	.half	.L174-.L292
	.byte	3,4,1,5,18,9
	.half	.L293-.L174
	.byte	3,7,1,3,92,1,7,9
	.half	.L77-.L293
	.byte	0,1,1
.L289:
	.sdecl	'.debug_ranges',debug,cluster('.cocofun_2')
	.sect	'.debug_ranges'
.L76:
	.word	-1,.L12,0,.L77-.L12,0,0
	.sdecl	'.debug_info',debug,cluster('.cocofun_3')
	.sect	'.debug_info'
.L78:
	.word	169
	.half	3
	.word	.L79
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L81,.L80
	.byte	2
	.word	.L29
	.byte	3
	.byte	'.cocofun_3',0,1,145,2,48,1
	.word	.L28,.L82,.L27
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('.cocofun_3')
	.sect	'.debug_abbrev'
.L79:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,0,3,8,58,15,59,15,57,15,54,15
	.byte	17,1,18,1,64,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('.cocofun_3')
	.sect	'.debug_line'
.L80:
	.word	.L295-.L294
.L294:
	.half	3
	.word	.L297-.L296
.L296:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L297:
	.byte	5,28,7,0,5,2
	.word	.L28
	.byte	3,163,10,1,5,18,9
	.half	.L298-.L28
	.byte	3,5,1,5,20,9
	.half	.L184-.L298
	.byte	3,9,1,5,18,9
	.half	.L299-.L184
	.byte	3,7,1,9
	.half	.L82-.L299
	.byte	0,1,1,5,28,0,5,2
	.word	.L28
	.byte	3,163,10,1,5,18,9
	.half	.L298-.L28
	.byte	3,5,1,5,20,9
	.half	.L184-.L298
	.byte	3,9,1,5,18,9
	.half	.L299-.L184
	.byte	3,7,1,9
	.half	.L82-.L299
	.byte	0,1,1
.L295:
	.sdecl	'.debug_ranges',debug,cluster('.cocofun_3')
	.sect	'.debug_ranges'
.L81:
	.word	-1,.L28,0,.L82-.L28,0,0
	.sdecl	'.debug_info',debug,cluster('.cocofun_4')
	.sect	'.debug_info'
.L83:
	.word	169
	.half	3
	.word	.L84
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L86,.L85
	.byte	2
	.word	.L29
	.byte	3
	.byte	'.cocofun_4',0,1,145,2,48,1
	.word	.L26,.L87,.L25
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('.cocofun_4')
	.sect	'.debug_abbrev'
.L84:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,0,3,8,58,15,59,15,57,15,54,15
	.byte	17,1,18,1,64,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('.cocofun_4')
	.sect	'.debug_line'
.L85:
	.word	.L301-.L300
.L300:
	.half	3
	.word	.L303-.L302
.L302:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L303:
	.byte	5,28,7,0,5,2
	.word	.L26
	.byte	3,163,10,1,5,18,9
	.half	.L304-.L26
	.byte	3,5,1,5,20,9
	.half	.L186-.L304
	.byte	3,9,1,5,18,9
	.half	.L305-.L186
	.byte	3,7,1,9
	.half	.L87-.L305
	.byte	0,1,1,5,28,0,5,2
	.word	.L26
	.byte	3,163,10,1,5,18,9
	.half	.L304-.L26
	.byte	3,5,1,5,20,9
	.half	.L186-.L304
	.byte	3,9,1,5,18,9
	.half	.L305-.L186
	.byte	3,7,1,9
	.half	.L87-.L305
	.byte	0,1,1
.L301:
	.sdecl	'.debug_ranges',debug,cluster('.cocofun_4')
	.sect	'.debug_ranges'
.L86:
	.word	-1,.L26,0,.L87-.L26,0,0
	.sdecl	'.debug_info',debug,cluster('.cocofun_5')
	.sect	'.debug_info'
.L88:
	.word	168
	.half	3
	.word	.L89
	.byte	4,1
	.byte	'..\\cstart.c',0
	.byte	'TASKING VX-toolset for TriCore: C compiler',0
	.byte	'D:\\00.Tasking_workspace\\DVRS_INTEL\\RGB_IR_INTEL_REV05\\Debug\\',0,12,1
	.word	.L91,.L90
	.byte	2
	.word	.L29
	.byte	3
	.byte	'.cocofun_5',0,1,116,13,1
	.word	.L16,.L92,.L15
	.byte	0
	.sdecl	'.debug_abbrev',debug,cluster('.cocofun_5')
	.sect	'.debug_abbrev'
.L89:
	.byte	1,17,1,3,8,37,8,27,8,19,15,128,70,12,85,6,16,6,0,0,2,61,0,24,16,0,0,3,46,0,3,8,58,15,59,15,57,15,54,15
	.byte	17,1,18,1,64,6,0,0,0
	.sdecl	'.debug_line',debug,cluster('.cocofun_5')
	.sect	'.debug_line'
.L90:
	.word	.L307-.L306
.L306:
	.half	3
	.word	.L309-.L308
.L308:
	.byte	2,1,-4,9,10,0,1,1,1,1,0,0,0,1,0
	.byte	'..\\cstart.c',0,0,0,0,0
.L309:
	.byte	5,32,7,0,5,2
	.word	.L16
	.byte	3,207,10,1,9
	.half	.L92-.L16
	.byte	0,1,1,5,32,0,5,2
	.word	.L16
	.byte	3,207,10,1,9
	.half	.L92-.L16
	.byte	0,1,1,5,32,0,5,2
	.word	.L16
	.byte	3,207,10,1,9
	.half	.L92-.L16
	.byte	0,1,1
.L307:
	.sdecl	'.debug_ranges',debug,cluster('.cocofun_5')
	.sect	'.debug_ranges'
.L91:
	.word	-1,.L16,0,.L92-.L16,0,0
	.sdecl	'.debug_loc',debug,cluster('.cocofun_1')
	.sect	'.debug_loc'
.L7:
	.word	-1,.L8,0,.L72-.L8
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('.cocofun_2')
	.sect	'.debug_loc'
.L11:
	.word	-1,.L12,0,.L77-.L12
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('.cocofun_3')
	.sect	'.debug_loc'
.L27:
	.word	-1,.L28,0,.L82-.L28
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('.cocofun_4')
	.sect	'.debug_loc'
.L25:
	.word	-1,.L26,0,.L87-.L26
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('.cocofun_5')
	.sect	'.debug_loc'
.L15:
	.word	-1,.L16,0,.L92-.L16
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_START')
	.sect	'.debug_loc'
.L19:
	.word	-1,.L20,0,.L171-.L20
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('__init_sp')
	.sect	'.debug_loc'
.L21:
	.word	-1,.L22,0,.L93-.L22
	.half	2
	.byte	138,0
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_endinit_clear')
	.sect	'.debug_loc'
.L5:
	.word	-1,.L6,0,.L152-.L6
	.half	2
	.byte	138,0
	.word	0,0
.L154:
	.word	0,0
.L156:
	.word	-1,.L6,.L172-.L6,.L72-.L6
	.half	1
	.byte	95
	.word	.L173-.L6,.L153-.L6
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_endinit_set')
	.sect	'.debug_loc'
.L9:
	.word	-1,.L10,0,.L157-.L10
	.half	2
	.byte	138,0
	.word	0,0
.L159:
	.word	0,0
.L161:
	.word	-1,.L10,.L174-.L10,.L77-.L10
	.half	1
	.byte	95
	.word	.L175-.L10,.L158-.L10
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_safety_endinit_clear')
	.sect	'.debug_loc'
.L13:
	.word	-1,.L14,0,.L162-.L14
	.half	2
	.byte	138,0
	.word	0,0
.L164:
	.word	0,0
.L166:
	.word	-1,.L14,.L172-.L14,.L72-.L14
	.half	1
	.byte	95
	.word	.L176-.L14,.L163-.L14
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_safety_endinit_set')
	.sect	'.debug_loc'
.L17:
	.word	-1,.L18,0,.L167-.L18
	.half	2
	.byte	138,0
	.word	0,0
.L169:
	.word	0,0
.L170:
	.word	-1,.L18,.L174-.L18,.L77-.L18
	.half	1
	.byte	95
	.word	.L177-.L18,.L168-.L18
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_loc',debug,cluster('_start')
	.sect	'.debug_loc'
.L23:
	.word	-1,.L24,0,.L94-.L24
	.half	2
	.byte	138,0
	.word	0,0
.L146:
	.word	-1,.L24,.L196-.L24,.L2-.L24
	.half	1
	.byte	98
	.word	.L197-.L24,.L198-.L24
	.half	1
	.byte	83
	.word	0,0
.L118:
	.word	0,0
.L105:
	.word	0,0
.L151:
	.word	-1,.L24,.L193-.L24,.L94-.L24
	.half	1
	.byte	95
	.word	0,0
.L143:
	.word	-1,.L24,.L3-.L24,.L195-.L24
	.half	1
	.byte	82
	.word	0,0
.L144:
	.word	-1,.L24,.L194-.L24,.L195-.L24
	.half	1
	.byte	81
	.word	0,0
.L100:
	.word	-1,.L24,.L178-.L24,.L179-.L24
	.half	1
	.byte	95
	.word	.L16-.L24,.L92-.L24
	.half	1
	.byte	95
	.word	.L8-.L24,.L180-.L24
	.half	1
	.byte	95
	.word	0,0
.L149:
	.word	-1,.L24,.L191-.L24,.L192-.L24
	.half	5
	.byte	144,32,157,32,0
	.word	.L199-.L24,.L195-.L24
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L148:
	.word	-1,.L24,.L198-.L24,.L2-.L24
	.half	1
	.byte	83
	.word	0,0
.L147:
	.word	-1,.L24,.L199-.L24,.L200-.L24
	.half	5
	.byte	144,32,157,32,0
	.word	0,0
.L122:
	.word	-1,.L24,.L184-.L24,.L82-.L24
	.half	1
	.byte	95
	.word	.L185-.L24,.L121-.L24
	.half	1
	.byte	95
	.word	0,0
.L126:
	.word	-1,.L24,.L186-.L24,.L87-.L24
	.half	1
	.byte	95
	.word	.L187-.L24,.L188-.L24
	.half	1
	.byte	95
	.word	0,0
.L135:
	.word	-1,.L24,.L186-.L24,.L87-.L24
	.half	1
	.byte	95
	.word	.L189-.L24,.L190-.L24
	.half	1
	.byte	95
	.word	0,0
.L131:
	.word	-1,.L24,.L184-.L24,.L82-.L24
	.half	1
	.byte	95
	.word	.L188-.L24,.L130-.L24
	.half	1
	.byte	95
	.word	0,0
.L137:
	.word	-1,.L24,.L174-.L24,.L77-.L24
	.half	1
	.byte	95
	.word	.L190-.L24,.L136-.L24
	.half	1
	.byte	95
	.word	0,0
.L107:
	.word	-1,.L24,.L172-.L24,.L72-.L24
	.half	1
	.byte	95
	.word	.L181-.L24,.L103-.L24
	.half	1
	.byte	95
	.word	0,0
.L110:
	.word	-1,.L24,.L174-.L24,.L77-.L24
	.half	1
	.byte	95
	.word	.L182-.L24,.L183-.L24
	.half	1
	.byte	95
	.word	0,0
.L115:
	.word	-1,.L24,.L172-.L24,.L72-.L24
	.half	1
	.byte	95
	.word	.L183-.L24,.L114-.L24
	.half	1
	.byte	95
	.word	0,0
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L310:
	.word	48
	.word	-1
	.byte	3,0,2,1,27,12,26,0,8,27,8,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36,8,37,8,38
	.byte	8,39
	.sdecl	'.debug_frame',debug,cluster('_endinit_clear')
	.sect	'.debug_frame'
	.word	24
	.word	.L310,.L6,.L152-.L6
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('_endinit_set')
	.sect	'.debug_frame'
	.word	24
	.word	.L310,.L10,.L157-.L10
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('_safety_endinit_clear')
	.sect	'.debug_frame'
	.word	24
	.word	.L310,.L14,.L162-.L14
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('_safety_endinit_set')
	.sect	'.debug_frame'
	.word	24
	.word	.L310,.L18,.L167-.L18
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('_START')
	.sect	'.debug_frame'
	.word	12
	.word	.L310,.L20,.L171-.L20
	.sdecl	'.debug_frame',debug,cluster('__init_sp')
	.sect	'.debug_frame'
	.word	12
	.word	.L310,.L22,.L93-.L22
	.sdecl	'.debug_frame',debug,cluster('_start')
	.sect	'.debug_frame'
	.word	12
	.word	.L310,.L24,.L94-.L24
	.sdecl	'.debug_frame',debug
	.sect	'.debug_frame'
.L311:
	.word	52
	.word	-1
	.byte	3,0,2,1,40,12,26,0,9,40,27,155,0,7,26,8,28,8,29,8,30,8,31,8,34,8,35,8,32,8,33,8,16,8,17,8,24,8,25,8,36
	.byte	8,37,8,38,8,39,0
	.sdecl	'.debug_frame',debug,cluster('.cocofun_1')
	.sect	'.debug_frame'
	.word	24
	.word	.L311,.L8,.L72-.L8
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('.cocofun_2')
	.sect	'.debug_frame'
	.word	24
	.word	.L311,.L12,.L77-.L12
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('.cocofun_5')
	.sect	'.debug_frame'
	.word	24
	.word	.L311,.L16,.L92-.L16
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('.cocofun_4')
	.sect	'.debug_frame'
	.word	24
	.word	.L311,.L26,.L87-.L26
	.byte	8,18,8,19,8,20,8,21,8,22,8,23
	.sdecl	'.debug_frame',debug,cluster('.cocofun_3')
	.sect	'.debug_frame'
	.word	24
	.word	.L311,.L28,.L82-.L28
	.byte	8,18,8,19,8,20,8,21,8,22,8,23

; ..\cstart.c	  1377  }
; ..\cstart.c	  1378  #endif
; ..\cstart.c	  1379  
; ..\cstart.c	  1380  #if     __CLOCKS_PER_SEC_INIT
; ..\cstart.c	  1381  static void setclockpersec(void)
; ..\cstart.c	  1382  {
; ..\cstart.c	  1383          unsigned long long hz = 0;
; ..\cstart.c	  1384  
; ..\cstart.c	  1385  #if defined PLL_CLC && defined __fOSC
; ..\cstart.c	  1386  
; ..\cstart.c	  1387  #if     (  defined _REGTC1130_H || defined _REGTC1164_H \ 
; ..\cstart.c	  1388          || defined _REGTC1166_H || defined _REGTC1762_H || defined _REGTC1764_H || defined _REGTC1766_H \ 
; ..\cstart.c	  1389          || defined _REGTC1766B_H || defined _REGTC1792_H || defined _REGTC1796_H || defined _REGTC1796B_H )
; ..\cstart.c	  1390  #define P               (PLL_CLC.B.PDIV+1)
; ..\cstart.c	  1391  #define N               (PLL_CLC.B.NDIV+1)
; ..\cstart.c	  1392  #define K               (PLL_CLC.B.KDIV+1)
; ..\cstart.c	  1393  #if     ( defined _REGTC1130_H )
; ..\cstart.c	  1394  #define __SYSFS__       SYSFSL
; ..\cstart.c	  1395  #else
; ..\cstart.c	  1396  #if     (  defined _REGTC1762_H || defined _REGTC1764_H || defined _REGTC1766B_H \ 
; ..\cstart.c	  1397          || defined _REGTC1164_H || defined _REGTC1166_H )
; ..\cstart.c	  1398  #define __SYSFS__       RSV
; ..\cstart.c	  1399  #else
; ..\cstart.c	  1400  #define __SYSFS__       SYSFS
; ..\cstart.c	  1401  #endif
; ..\cstart.c	  1402  #endif
; ..\cstart.c	  1403  #define SYSCLK(CPUCLK)  (CPUCLK/(2-PLL_CLC.B.__SYSFS__))
; ..\cstart.c	  1404  #define STMCLK(CPUCLK)  (SYSCLK(CPUCLK)/STM_CLC.B.RMC)
; ..\cstart.c	  1405  #define FVCOBASE        __fOSC
; ..\cstart.c	  1406          if ( PLL_CLC.B.BYPPIN )                                                         /* Direct drive */
; ..\cstart.c	  1407          {
; ..\cstart.c	  1408                  hz = STMCLK(__fOSC);
; ..\cstart.c	  1409          }
; ..\cstart.c	  1410          else
; ..\cstart.c	  1411          {
; ..\cstart.c	  1412                  if ( PLL_CLC.B.VCOBYP )                                                 /* VCO Bypass Mode */
; ..\cstart.c	  1413                  {
; ..\cstart.c	  1414                          hz = STMCLK(__fOSC/(P*K));
; ..\cstart.c	  1415                  }
; ..\cstart.c	  1416                  else
; ..\cstart.c	  1417                  {
; ..\cstart.c	  1418                          if ( !PLL_CLC.B.OSCDISC && PLL_CLC.B.LOCK )     /* PLL Mode */
; ..\cstart.c	  1419                          {
; ..\cstart.c	  1420                                  hz = STMCLK((N*__fOSC)/(P*K));
; ..\cstart.c	  1421                          }
; ..\cstart.c	  1422                          else                                                                            /* PLL base mode */
; ..\cstart.c	  1423                          {
; ..\cstart.c	  1424                                  hz = STMCLK(FVCOBASE/K);
; ..\cstart.c	  1425                          }
; ..\cstart.c	  1426                  }
; ..\cstart.c	  1427          }
; ..\cstart.c	  1428  #endif
; ..\cstart.c	  1429  #endif
; ..\cstart.c	  1430  
; ..\cstart.c	  1431  #if     ( ( defined SCU_PLLSTAT && defined SCU_PLLCON0 && defined SCU_PLLCON1 ) \ 
; ..\cstart.c	  1432            || ( defined SCU_SYSPLLCON0 && defined SCU_SYSPLLCON1 ) && defined __fOSC )
; ..\cstart.c	  1433  #if     (  defined _REGTC1167_H || defined _REGTC1197_H || defined _REGTC1337_H || defined _REGTC1367_H \ 
; ..\cstart.c	  1434          || defined _REGTC1387_H || defined _REGTC1728_H \ 
; ..\cstart.c	  1435          || defined _REGTC1736_H || defined _REGTC1738_H || defined _REGTC1746_H \ 
; ..\cstart.c	  1436          || defined _REGTC1747_H || defined _REGTC1748_H || defined _REGTC1767_H || defined _REGTC1768_H \ 
; ..\cstart.c	  1437          || defined _REGTC1782_H || defined _REGTC1784_H || defined _REGTC1184_H || defined _REGTC1797_H \ 
; ..\cstart.c	  1438          || defined _REGTC1791_H || defined _REGTC1793_H || defined _REGTC1798_H || defined _REGTC1724_H \ 
; ..\cstart.c	  1439          || defined _REGTC21X_H  || defined _REGTC22X_H  || defined _REGTC23X_ADAS_H || defined _REGTC23X_H \ 
; ..\cstart.c	  1440          || defined _REGTC27X_H  || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H \ 
; ..\cstart.c	  1441          || defined _REGTC26X_H  || defined _REGTC26XB_H || defined _REGTC29X_H  || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	  1442  #if     ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	  1443  #define P               (SCU_SYSPLLCON0.B.PDIV+1)
; ..\cstart.c	  1444  #define N               (SCU_SYSPLLCON0.B.NDIV+1)
; ..\cstart.c	  1445  #define K2              (SCU_SYSPLLCON1.B.K2DIV+1)
; ..\cstart.c	  1446  #else
; ..\cstart.c	  1447  #define P               (SCU_PLLCON0.B.PDIV+1)
; ..\cstart.c	  1448  #define N               (SCU_PLLCON0.B.NDIV+1)
; ..\cstart.c	  1449  #define K1              (SCU_PLLCON1.B.K1DIV+1)
; ..\cstart.c	  1450  #define K2              (SCU_PLLCON1.B.K2DIV+1)
; ..\cstart.c	  1451  #endif
; ..\cstart.c	  1452  #if     ( defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	  1453  #define STM_CLC_RMC     1
; ..\cstart.c	  1454  #else   
; ..\cstart.c	  1455  #define STM_CLC_RMC     (STM_CLC.B.RMC)         
; ..\cstart.c	  1456  #endif
; ..\cstart.c	  1457  #if     ( defined _REGTC1337_H || defined _REGTC1367_H || defined _REGTC1387_H || defined _REGTC1768_H )
; ..\cstart.c	  1458  #define SYSCLK(CPUCLK)  (CPUCLK)
; ..\cstart.c	  1459  #else
; ..\cstart.c	  1460  #if ( defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H )
; ..\cstart.c	  1461  #define SYSCLK(CPUCLK)  (CPUCLK/SCU_CCUCON1.B.STMDIV)
; ..\cstart.c	  1462  #else
; ..\cstart.c	  1463  #if ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	  1464  #define SYSCLK(CPUCLK)  (CPUCLK/SCU_CCUCON0.B.STMDIV)
; ..\cstart.c	  1465  #else
; ..\cstart.c	  1466  #define SYSCLK(CPUCLK)  (CPUCLK/(SCU_CCUCON0.B.FPIDIV+1))
; ..\cstart.c	  1467  #endif
; ..\cstart.c	  1468  #endif
; ..\cstart.c	  1469  #endif
; ..\cstart.c	  1470  #define STMCLK(CPUCLK)  (SYSCLK(CPUCLK)/STM_CLC_RMC)
; ..\cstart.c	  1471  #define FVCOBASE        __fOSC
; ..\cstart.c	  1472  #if     !( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	  1473          if ( SCU_PLLSTAT.B.VCOBYST )    /* Prescaler mode */
; ..\cstart.c	  1474          {
; ..\cstart.c	  1475                  hz = STMCLK(__fOSC/K1);
; ..\cstart.c	  1476          }
; ..\cstart.c	  1477          else
; ..\cstart.c	  1478  #endif
; ..\cstart.c	  1479  #if ( defined _REGTC21X_H || defined _REGTC22X_H || defined _REGTC23X_ADAS_H || defined _REGTC23X_H || defined _REGTC27X_H || defined _REGTC27XB_H || defined _REGTC27XC_H || defined _REGTC27XD_H || defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC29X_H || defined _REGTC29XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	  1480          if ( SCU_CCUCON0.B.CLKSEL==0)
; ..\cstart.c	  1481          {
; ..\cstart.c	  1482                  hz = STMCLK(100000000);         /* back-up clock */
; ..\cstart.c	  1483          }
; ..\cstart.c	  1484          else
; ..\cstart.c	  1485  #endif
; ..\cstart.c	  1486  #if ( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	  1487          if ( SCU_CCUCON0.B.CLKSEL==2 )
; ..\cstart.c	  1488          {
; ..\cstart.c	  1489                  hz = STMCLK(20000000);          /* SYSCLK clock */
; ..\cstart.c	  1490          }
; ..\cstart.c	  1491          else
; ..\cstart.c	  1492  #endif
; ..\cstart.c	  1493          {
; ..\cstart.c	  1494  #if     !( defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H || defined _REGUSERDEF162_H )
; ..\cstart.c	  1495                  if ( SCU_PLLSTAT.B.FINDIS )     /* Free running mode */
; ..\cstart.c	  1496                  {
; ..\cstart.c	  1497                          hz = STMCLK(FVCOBASE/K2);
; ..\cstart.c	  1498                  }
; ..\cstart.c	  1499                  else                                            /* Normal mode */
; ..\cstart.c	  1500  #endif
; ..\cstart.c	  1501                  {
; ..\cstart.c	  1502                          hz = STMCLK((N*__fOSC)/(P*K2));
; ..\cstart.c	  1503                  }
; ..\cstart.c	  1504          }
; ..\cstart.c	  1505  #endif
; ..\cstart.c	  1506  #endif
; ..\cstart.c	  1507          
; ..\cstart.c	  1508          setfoschz ( hz );
; ..\cstart.c	  1509  }
; ..\cstart.c	  1510  #endif
; ..\cstart.c	  1511  
; ..\cstart.c	  1512  #if ( defined _REGTC26X_H || defined _REGTC26XB_H || defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	  1513  #if __XC800_INIT
; ..\cstart.c	  1514  
; ..\cstart.c	  1515  static  void inline scr_enable( void );
; ..\cstart.c	  1516  static  void scr_boot( unsigned char boot_mode );
; ..\cstart.c	  1517  static  _Bool scr_init( void );
; ..\cstart.c	  1518  
; ..\cstart.c	  1519  #if ( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	  1520  #define __PMSWCR2       SCU_PMSWCR2
; ..\cstart.c	  1521  #define __PMSWCRx       SCU_PMSWCR1
; ..\cstart.c	  1522  #define __PMSWCRx_type  SCU_PMSWCR1_type
; ..\cstart.c	  1523  #define __PMSWSTAT      SCU_PMSWSTAT
; ..\cstart.c	  1524  #define __PMSWSTATCLR   SCU_PMSWSTATCLR
; ..\cstart.c	  1525  #endif
; ..\cstart.c	  1526  
; ..\cstart.c	  1527  #if (  defined _REGTC38X_H || defined _REGTC39X_H || defined _REGTC39XB_H )
; ..\cstart.c	  1528  #define __PMSWCR2       PMS_PMSWCR2
; ..\cstart.c	  1529  #define __PMSWCRx       PMS_PMSWCR4
; ..\cstart.c	  1530  #define __PMSWCRx_type  PMS_PMSWCR4_type
; ..\cstart.c	  1531  #define __PMSWSTAT      PMS_PMSWSTAT
; ..\cstart.c	  1532  #define __PMSWSTATCLR   PMS_PMSWSTATCLR
; ..\cstart.c	  1533  #define __XRAM_ADDR     (void *)0xf0240000
; ..\cstart.c	  1534  #endif
; ..\cstart.c	  1535  
; ..\cstart.c	  1536  #if ( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	  1537  static  void inline scr_wait( void );
; ..\cstart.c	  1538  static  void qspi2_init( void );
; ..\cstart.c	  1539  static  void qspi2_end( void );
; ..\cstart.c	  1540  static  void inline qspi2_end_of_frame( void );
; ..\cstart.c	  1541  static  void inline qspi2_start_of_frame( void );
; ..\cstart.c	  1542  static  void qspi2_send_data( unsigned int data_entry );
; ..\cstart.c	  1543  static  void qspi2_write_word( unsigned short address, unsigned short data );
; ..\cstart.c	  1544  void    _scr_write( const unsigned char *romdata, unsigned int length );
; ..\cstart.c	  1545  
; ..\cstart.c	  1546  #ifdef _USER_MODE_1
; ..\cstart.c	  1547  static  void inline scr_set_user_mode_1( void );
; ..\cstart.c	  1548  #endif
; ..\cstart.c	  1549  
; ..\cstart.c	  1550  
; ..\cstart.c	  1551  #endif
; ..\cstart.c	  1552  
; ..\cstart.c	  1553  
; ..\cstart.c	  1554  static void inline scr_enable( void )
; ..\cstart.c	  1555  {
; ..\cstart.c	  1556  #if ( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	  1557          /*
; ..\cstart.c	  1558           *      Set SCU_PMSWCR0.SCREN Standby Controller is enabled
; ..\cstart.c	  1559           *      set SCU_PMSWCR0.SCRCLKSEL Both 100 KHz Oscillator
; ..\cstart.c	  1560           *      and 100 MHz oscillator are active in Standby Mode
; ..\cstart.c	  1561           */
; ..\cstart.c	  1562          SCU_PMSWCR0.U |= (0x1 << 16) | (0x1 << 19);
; ..\cstart.c	  1563  #else
; ..\cstart.c	  1564          /*
; ..\cstart.c	  1565           *      Set PMS_PMSWCR4.SCREN Standby Controller is enabled
; ..\cstart.c	  1566           *      set PMS_PMSWCR4.SCRCLKSEL Both 70 KHz Oscillator
; ..\cstart.c	  1567           *      and 100 MHz oscillator are active in Standby Mode
; ..\cstart.c	  1568           */
; ..\cstart.c	  1569          PMS_PMSWCR4.U |= (0x1 << 25) | (0x1 << 6);
; ..\cstart.c	  1570  #endif
; ..\cstart.c	  1571  
; ..\cstart.c	  1572          /*
; ..\cstart.c	  1573           *      Wait until Standby Controller is enabled.
; ..\cstart.c	  1574           *      This bit is updated when PMSWCR0.SCREN bit is set.
; ..\cstart.c	  1575           */
; ..\cstart.c	  1576          while( !__PMSWSTAT.B.SCR )
; ..\cstart.c	  1577          {
; ..\cstart.c	  1578                  /* wait until enabled */
; ..\cstart.c	  1579          }
; ..\cstart.c	  1580  }
; ..\cstart.c	  1581  
; ..\cstart.c	  1582  static void scr_boot( unsigned char boot_mode )
; ..\cstart.c	  1583  {
; ..\cstart.c	  1584          /*
; ..\cstart.c	  1585           *      Set __PMSWCRx.SCRSTEN aka .BPSCRSTREQ so SCRSTREQ can be updated
; ..\cstart.c	  1586           *      Set __PMSWCRx.SCRSTREQ for Standby Controller reset request
; ..\cstart.c	  1587           *      set __PMSWCRx.SCRCFG [23:16] boot_mode
; ..\cstart.c	  1588           *              00H 8 bit XRAM is not programmed
; ..\cstart.c	  1589           *              01H User Mode (Execution from t.b.d XRAM address)
; ..\cstart.c	  1590           *              02H User Mode (DAP mode active)
; ..\cstart.c	  1591           *              03H User Mode (SPD mode active)
; ..\cstart.c	  1592           *
; ..\cstart.c	  1593           *      Note: Any change in SCRCFG is followed by a SCRSTREQ reset request
; ..\cstart.c	  1594           *      of the xc800 controller to start off in the chosen mode.
; ..\cstart.c	  1595           */
; ..\cstart.c	  1596          __PMSWCRx_type          regval;
; ..\cstart.c	  1597          regval.U = __PMSWCRx.U;
; ..\cstart.c	  1598  #if ( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	  1599          regval.B.SCRSTEN = 1;
; ..\cstart.c	  1600  #else
; ..\cstart.c	  1601          regval.B.BPSCRSTREQ = 1;
; ..\cstart.c	  1602  #endif
; ..\cstart.c	  1603          regval.B.SCRSTREQ = 1;
; ..\cstart.c	  1604          regval.B.SCRCFG = boot_mode;
; ..\cstart.c	  1605          __PMSWCRx.U = regval.U;
; ..\cstart.c	  1606  
; ..\cstart.c	  1607          /*
; ..\cstart.c	  1608           *      Wait until Reset of Standby controller took place.
; ..\cstart.c	  1609           */
; ..\cstart.c	  1610          while( !__PMSWSTAT.B.SCRST )
; ..\cstart.c	  1611          {
; ..\cstart.c	  1612                  /* Wait until reset */
; ..\cstart.c	  1613          }
; ..\cstart.c	  1614  
; ..\cstart.c	  1615          /*
; ..\cstart.c	  1616           *      Clear PMSWSTAT.SCRST after reset took place
; ..\cstart.c	  1617           */
; ..\cstart.c	  1618          __PMSWSTATCLR.B.SCRSTCLR = 1;
; ..\cstart.c	  1619  
; ..\cstart.c	  1620          /*
; ..\cstart.c	  1621           *      SCRINT [7:0] Data exchange from Standby Controller to SCU.
; ..\cstart.c	  1622           *
; ..\cstart.c	  1623           *      Boot mode 0:
; ..\cstart.c	  1624           *      At the end of startup code, an interrupt would be triggered to
; ..\cstart.c	  1625           *      the main controller by setting bit NMICON.SCRINTTC to 1 with a
; ..\cstart.c	  1626           *      value of 80H in SCRINT register. This is used to indicate
; ..\cstart.c	  1627           *      that TC2x_SCR is ready for CPUx to download code to XRAM.
; ..\cstart.c	  1628           *
; ..\cstart.c	  1629           *      Boot mode 1:
; ..\cstart.c	  1630           *      XRAM pattern found then, the same interrupt is triggered to the
; ..\cstart.c	  1631           *      main controller with a value of 80H in SCRINT register to
; ..\cstart.c	  1632           *      indicate the execution of user code.
; ..\cstart.c	  1633           *
; ..\cstart.c	  1634           *      A value of 81H in SCRINT indicates that boot failed.
; ..\cstart.c	  1635           */
; ..\cstart.c	  1636          while( __PMSWCR2.B.SCRINT != 0x80
; ..\cstart.c	  1637                 && __PMSWCR2.B.SCRINT != 0x81
; ..\cstart.c	  1638                 )
; ..\cstart.c	  1639          {
; ..\cstart.c	  1640                  /* Wait until end of boot mode reached */
; ..\cstart.c	  1641          }
; ..\cstart.c	  1642  }
; ..\cstart.c	  1643  
; ..\cstart.c	  1644  static _Bool scr_init( void )
; ..\cstart.c	  1645  {
; ..\cstart.c	  1646          _Bool download = 0;
; ..\cstart.c	  1647  
; ..\cstart.c	  1648          _safety_endinit_clear();
; ..\cstart.c	  1649  
; ..\cstart.c	  1650          scr_enable();
; ..\cstart.c	  1651  
; ..\cstart.c	  1652          /*
; ..\cstart.c	  1653           *      For Infineon TriBoard tc26x the suspend mode is supported
; ..\cstart.c	  1654           *      and can not be disabled. PMSWSTAT.HWCFGEVR=7
; ..\cstart.c	  1655           *      The Standby Controller Reset Indication flag is always zero
; ..\cstart.c	  1656           *      after any kind of reset. __PMSWSTAT.SCRST=0
; ..\cstart.c	  1657           *
; ..\cstart.c	  1658           *      Upon cold power-on, the XRAM can be programmed immediately
; ..\cstart.c	  1659           *      when __PMSWCRx.SCRCFG=0 indicates that it is not programmed
; ..\cstart.c	  1660           *      and __PMSWCR2.B.SCRINT=0x80 indicates that it is booted,
; ..\cstart.c	  1661           *      else request for boot mode 0.
; ..\cstart.c	  1662           *
; ..\cstart.c	  1663           *      When the SCR is executing from XRAM after TriCore reset 
; ..\cstart.c	  1664           *      it is operating in standby mode __PMSWCRx.SCRCFG=1, no
; ..\cstart.c	  1665           *      download should be required. For debugging TriCore download to
; ..\cstart.c	  1666           *      SCR it might be required to force downloading, this requires a
; ..\cstart.c	  1667           *      boot mode 0 request. Enable _SCR_FORCE_DOWNLOAD.
; ..\cstart.c	  1668           */
; ..\cstart.c	  1669  //      #define _SCR_FORCE_DOWNLOAD
; ..\cstart.c	  1670  
; ..\cstart.c	  1671          if ( __PMSWCRx.B.SCRCFG == 0 )
; ..\cstart.c	  1672          {
; ..\cstart.c	  1673                  if ( __PMSWCR2.B.SCRINT == 0x80 )
; ..\cstart.c	  1674                  {
; ..\cstart.c	  1675                          download = 1;           /* Download to XRAM */
; ..\cstart.c	  1676                  }
; ..\cstart.c	  1677                  else
; ..\cstart.c	  1678                  {
; ..\cstart.c	  1679                          /*
; ..\cstart.c	  1680                           *      When the TriCore is (soft) reset after a cold
; ..\cstart.c	  1681                           *      boot of the SCR the SCRINT is not valid any
; ..\cstart.c	  1682                           *      more, request for boot mode 0.
; ..\cstart.c	  1683                           */
; ..\cstart.c	  1684                          scr_boot( 0 );
; ..\cstart.c	  1685                          if ( __PMSWCR2.B.SCRINT == 0x80 )
; ..\cstart.c	  1686                          {
; ..\cstart.c	  1687                                  download = 1;   /* Download to XRAM */
; ..\cstart.c	  1688                          }
; ..\cstart.c	  1689                  }
; ..\cstart.c	  1690          }
; ..\cstart.c	  1691          else if ( __PMSWCRx.B.SCRCFG == 1 )
; ..\cstart.c	  1692          {
; ..\cstart.c	  1693                  /*
; ..\cstart.c	  1694                   *      SCR is already running in user mode 1,
; ..\cstart.c	  1695                   *      code is not downloaded by default.
; ..\cstart.c	  1696                   */
; ..\cstart.c	  1697  #ifdef _SCR_FORCE_DOWNLOAD
; ..\cstart.c	  1698                  scr_boot( 0 );
; ..\cstart.c	  1699                  if ( __PMSWCR2.B.SCRINT == 0x80 )
; ..\cstart.c	  1700                  {
; ..\cstart.c	  1701                          download = 1;           /* Download to XRAM */
; ..\cstart.c	  1702                  }
; ..\cstart.c	  1703  #endif
; ..\cstart.c	  1704          }
; ..\cstart.c	  1705          else
; ..\cstart.c	  1706          {
; ..\cstart.c	  1707                  /*
; ..\cstart.c	  1708                   *      SCR debug DAP or SPD user mode
; ..\cstart.c	  1709                   *      no TriCore download.
; ..\cstart.c	  1710                   */
; ..\cstart.c	  1711          }
; ..\cstart.c	  1712  
; ..\cstart.c	  1713          _safety_endinit_set();
; ..\cstart.c	  1714  
; ..\cstart.c	  1715          return download;
; ..\cstart.c	  1716  }
; ..\cstart.c	  1717  
; ..\cstart.c	  1718  _Bool _scr_start( void )
; ..\cstart.c	  1719  {
; ..\cstart.c	  1720          _Bool start = 0;
; ..\cstart.c	  1721          
; ..\cstart.c	  1722          _safety_endinit_clear();
; ..\cstart.c	  1723  
; ..\cstart.c	  1724          scr_boot( 1 );                          /* Reset xc800 to start user code */
; ..\cstart.c	  1725  
; ..\cstart.c	  1726          if ( __PMSWCR2.B.SCRINT == 0x80 )
; ..\cstart.c	  1727          {
; ..\cstart.c	  1728                  start = 1;                      /* User code started */
; ..\cstart.c	  1729          }
; ..\cstart.c	  1730                  
; ..\cstart.c	  1731          _safety_endinit_set();
; ..\cstart.c	  1732  
; ..\cstart.c	  1733          return  start;
; ..\cstart.c	  1734  }
; ..\cstart.c	  1735  
; ..\cstart.c	  1736  
; ..\cstart.c	  1737  /*
; ..\cstart.c	  1738   *      The image of the xc800 has a fixed length
; ..\cstart.c	  1739   */
; ..\cstart.c	  1740  #define LENGTH  1024*8/sizeof(unsigned int)
; ..\cstart.c	  1741  extern unsigned int const _lc_ub__rodata_xc800init[LENGTH];
; ..\cstart.c	  1742  
; ..\cstart.c	  1743  #if !( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	  1744  /* library version uses double word instructions this causes exception with XRAM */
; ..\cstart.c	  1745  static void localmemcpy(unsigned int * dest, unsigned int const * src, int len)
; ..\cstart.c	  1746  {
; ..\cstart.c	  1747          for (int i = 0; i < len; i++)
; ..\cstart.c	  1748          {
; ..\cstart.c	  1749                  dest[i] = src[i];
; ..\cstart.c	  1750          }
; ..\cstart.c	  1751  }
; ..\cstart.c	  1752  #endif
; ..\cstart.c	  1753  
; ..\cstart.c	  1754  static void _xc800_init ( void )
; ..\cstart.c	  1755  {
; ..\cstart.c	  1756          if ( scr_init() )                                       /* Only download when allowed */
; ..\cstart.c	  1757          {
; ..\cstart.c	  1758  #if ( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	  1759                  qspi2_init();
; ..\cstart.c	  1760  
; ..\cstart.c	  1761                  _scr_write( (unsigned char const *)_lc_ub__rodata_xc800init, LENGTH*sizeof(unsigned int) );     /* write data to xc800 xram */
; ..\cstart.c	  1762  
; ..\cstart.c	  1763  #ifdef _USER_MODE_1
; ..\cstart.c	  1764                  /*
; ..\cstart.c	  1765                   *      The XRAM signature should be part of your xc800
; ..\cstart.c	  1766                   *      application ROM image.
; ..\cstart.c	  1767                   */
; ..\cstart.c	  1768                  scr_set_user_mode_1();                          /* Set XRAM signature */
; ..\cstart.c	  1769  #endif
; ..\cstart.c	  1770                  qspi2_end();
; ..\cstart.c	  1771  #else
; ..\cstart.c	  1772                  localmemcpy( __XRAM_ADDR, _lc_ub__rodata_xc800init, LENGTH );
; ..\cstart.c	  1773  #endif
; ..\cstart.c	  1774          }
; ..\cstart.c	  1775  }
; ..\cstart.c	  1776  
; ..\cstart.c	  1777  #if ( defined _REGTC26X_H || defined _REGTC26XB_H )
; ..\cstart.c	  1778  /*
; ..\cstart.c	  1779   *      The SCR interacts with the main core domain via a dedicated
; ..\cstart.c	  1780   *      SPI (QSPI2) interface and PMSWCR2 register bits.
; ..\cstart.c	  1781   */
; ..\cstart.c	  1782  static void inline scr_wait( void )
; ..\cstart.c	  1783  {
; ..\cstart.c	  1784          /*
; ..\cstart.c	  1785           *      SCR Arbiter Busy status flag, when set the RAM is
; ..\cstart.c	  1786           *      not accessible via QSPI as the arbiter is currently
; ..\cstart.c	  1787           *      busy.
; ..\cstart.c	  1788           */
; ..\cstart.c	  1789          while( SCU_PMSWCR2.B.BUSY )
; ..\cstart.c	  1790          {
; ..\cstart.c	  1791                  /* Wait */
; ..\cstart.c	  1792          }
; ..\cstart.c	  1793  }
; ..\cstart.c	  1794  
; ..\cstart.c	  1795  #ifdef _USER_MODE_1
; ..\cstart.c	  1796  /*
; ..\cstart.c	  1797   *      The XRAM signature should be part of your XC800
; ..\cstart.c	  1798   *      application ROM image. For example:
; ..\cstart.c	  1799   *      __rom const unsigned char boot_mode_1[8] __at( 0x1ff8 ) =
; ..\cstart.c	  1800   *      {0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa};
; ..\cstart.c	  1801   *
; ..\cstart.c	  1802   *      Set XRAM User Mode 1
; ..\cstart.c	  1803   *
; ..\cstart.c	  1804   *      If the User mode 1 is selected, the Boot ROM will jump to program memory
; ..\cstart.c	  1805   *      address 0000H to execute the user code in the XRAM memory. To use this
; ..\cstart.c	  1806   *      mode, the XRAM must be pre-loaded with user code. This is the normal
; ..\cstart.c	  1807   *      operating mode of the TC2x_SCR. For the last 8 bytes of XRAM starting
; ..\cstart.c	  1808   *      at address 0FF8H, user need to program 4 sets of pre-fixed bytes with
; ..\cstart.c	  1809   *      each set containing 55H followed by AAH. User code will not be executed
; ..\cstart.c	  1810   *      and SCR will enter an endless loop if the memory content does not match
; ..\cstart.c	  1811   *      these data sequence. It is used to avoid an unintentional entry to User
; ..\cstart.c	  1812   *      Mode 1. Before entering the endless loop, the start-up code will trigger
; ..\cstart.c	  1813   *      an interrupt to the main controller by setting bit NMICON.SCRINTTC to 1
; ..\cstart.c	  1814   *      with a value of 81H in SCRINTEXCHG register. If there is a match, the same
; ..\cstart.c	  1815   *      interrupt is triggered to the main controller with a value of 80H in
; ..\cstart.c	  1816   *      SCRINTEXCHG register to indicate the execution of user code.
; ..\cstart.c	  1817   *
; ..\cstart.c	  1818   */
; ..\cstart.c	  1819  static void inline scr_set_user_mode_1( void )
; ..\cstart.c	  1820  {
; ..\cstart.c	  1821          unsigned char i;
; ..\cstart.c	  1822  
; ..\cstart.c	  1823          qspi2_start_of_frame();
; ..\cstart.c	  1824  
; ..\cstart.c	  1825          for( i = 0; i < 4; i++ )
; ..\cstart.c	  1826          {
; ..\cstart.c	  1827                  qspi2_write_word( 0x1FF8 + 2*i, 0xAA55 );
; ..\cstart.c	  1828          }
; ..\cstart.c	  1829  
; ..\cstart.c	  1830          qspi2_end_of_frame();
; ..\cstart.c	  1831  }
; ..\cstart.c	  1832  #endif
; ..\cstart.c	  1833  
; ..\cstart.c	  1834  
; ..\cstart.c	  1835  void _scr_write( const unsigned char *romdata, unsigned int length )
; ..\cstart.c	  1836  {
; ..\cstart.c	  1837          unsigned short addr;
; ..\cstart.c	  1838          unsigned short data;
; ..\cstart.c	  1839  
; ..\cstart.c	  1840          qspi2_start_of_frame();
; ..\cstart.c	  1841          
; ..\cstart.c	  1842          for( addr = 0; addr < length; addr += 2 )
; ..\cstart.c	  1843          {
; ..\cstart.c	  1844                  data = romdata[addr] | (romdata[addr + 1] << 8);
; ..\cstart.c	  1845                  qspi2_write_word( addr, data );
; ..\cstart.c	  1846          }
; ..\cstart.c	  1847          
; ..\cstart.c	  1848          qspi2_end_of_frame();
; ..\cstart.c	  1849  }
; ..\cstart.c	  1850  
; ..\cstart.c	  1851  
; ..\cstart.c	  1852  /*
; ..\cstart.c	  1853   *      QSPI2 Configuration for transferring data to and from XRAM.
; ..\cstart.c	  1854   */
; ..\cstart.c	  1855  enum {
; ..\cstart.c	  1856          TOS_CPU0=0,
; ..\cstart.c	  1857          TOS_CPU1=1,
; ..\cstart.c	  1858          TOS_CPU2=2
; ..\cstart.c	  1859  };
; ..\cstart.c	  1860  
; ..\cstart.c	  1861  #define QSPI2_INTERRUPT_NR      255
; ..\cstart.c	  1862  
; ..\cstart.c	  1863  /*
; ..\cstart.c	  1864   *      Baud rate configuration QSPI2
; ..\cstart.c	  1865   *      Baud rate = fBAUD2 / ((QSPI2TQ+1) * (ECONQ+1) * (ECONA+1 + ECONB + ECONC ) )
; ..\cstart.c	  1866   *      50Mbaud = 200Mhz/4
; ..\cstart.c	  1867   */
; ..\cstart.c	  1868  #define QSPI2TQ 0
; ..\cstart.c	  1869  #define ECONQ   0
; ..\cstart.c	  1870  #define ECONA   1
; ..\cstart.c	  1871  #define ECONB   2
; ..\cstart.c	  1872  #define ECONC   0
; ..\cstart.c	  1873  #define ECON    ((ECONQ) | (ECONA << 6) | (ECONB << 8) | (ECONC << 10))
; ..\cstart.c	  1874  
; ..\cstart.c	  1875  static void qspi2_init( void )
; ..\cstart.c	  1876  {
; ..\cstart.c	  1877          _endinit_clear();
; ..\cstart.c	  1878  
; ..\cstart.c	  1879          QSPI2_CLC.U=0x8;                        /* Enable QSPI2 */
; ..\cstart.c	  1880  
; ..\cstart.c	  1881          _endinit_set();
; ..\cstart.c	  1882  
; ..\cstart.c	  1883          QSPI2_GLOBALCON.B.TQ = QSPI2TQ;         /* Divide Global Time Quantum Length */
; ..\cstart.c	  1884          QSPI2_PISEL.B.MRIS = 0x7;               /* SPI MRST input MRST2H (7=H,0..7->A..H) */
; ..\cstart.c	  1885          QSPI2_GLOBALCON1.U = (0x3 << 9);        /* Tx and Rx Interrupt Event Enabled */
; ..\cstart.c	  1886          QSPI2_ECON7.U = ECON;                   /* Set baud rate */
; ..\cstart.c	  1887          QSPI2_SSOC.U = (0x1 << 31);             /* Enable SLSO Output 31 */
; ..\cstart.c	  1888          QSPI2_GLOBALCON.B.EN = 1;               /* RUN requested */
; ..\cstart.c	  1889  
; ..\cstart.c	  1890          /*
; ..\cstart.c	  1891           * QSPI2 is serviced by TOS_CPU0
; ..\cstart.c	  1892           *
; ..\cstart.c	  1893           * [0..7] SRPN=QSPI2_TXRX_INTERRUPT_NR
; ..\cstart.c	  1894           * [10] Service Request enable
; ..\cstart.c	  1895           * [11..12] TOS=TriCore interrupt 0=CPU0, 1=CPU1, 2=CPU2, 3=SDMA, 4=DMA
; ..\cstart.c	  1896           */
; ..\cstart.c	  1897          SRC_QSPI2TX.U = QSPI2_INTERRUPT_NR | ( 1<<10 ) | (TOS_CPU0<<11);
; ..\cstart.c	  1898          SRC_QSPI2RX.U = QSPI2_INTERRUPT_NR | ( 1<<10 ) | (TOS_CPU0<<11);
; ..\cstart.c	  1899          
; ..\cstart.c	  1900          __enable();                             /* QSPI2 interrupts are serviced */
; ..\cstart.c	  1901  }
; ..\cstart.c	  1902  
; ..\cstart.c	  1903  static void qspi2_end( void )
; ..\cstart.c	  1904  {
; ..\cstart.c	  1905          QSPI2_GLOBALCON.B.EN = 0;               /* PAUSE requested */
; ..\cstart.c	  1906  
; ..\cstart.c	  1907          SRC_QSPI2TX.U = 0;                      /* QSPI2 TX service disabled */
; ..\cstart.c	  1908          SRC_QSPI2RX.U = 0;                      /* QSPI2 RX service disabled */
; ..\cstart.c	  1909  
; ..\cstart.c	  1910          __disable();                            /* QSPI2 interrupts are disabled */
; ..\cstart.c	  1911          
; ..\cstart.c	  1912          _endinit_clear();
; ..\cstart.c	  1913  
; ..\cstart.c	  1914          QSPI2_CLC.U = 0x1;                      /* Disable QSPI2 */
; ..\cstart.c	  1915  
; ..\cstart.c	  1916          _endinit_set();
; ..\cstart.c	  1917  }
; ..\cstart.c	  1918  
; ..\cstart.c	  1919  static void inline qspi2_start_of_frame( void )
; ..\cstart.c	  1920  {
; ..\cstart.c	  1921          /*
; ..\cstart.c	  1922           *      The communication between the main TC2x system and XRAM is
; ..\cstart.c	  1923           *      based on a pre-fixed SPI software protocol.
; ..\cstart.c	  1924           *
; ..\cstart.c	  1925           *      BACON_ENTRY     Writes to this location are BACON configurations
; ..\cstart.c	  1926           *      BACON.TRAIL     Trailing Delay Length 2 TQSPI units
; ..\cstart.c	  1927           *      BACON.MSB       Shift MSB first
; ..\cstart.c	  1928           *      BACON.BYTE      Data length in bits
; ..\cstart.c	  1929           *      BACON.DL        Data Length 32 bits
; ..\cstart.c	  1930           *      BACON.BS        SLSO15 channel select. Access the SCR XRAM
; ..\cstart.c	  1931           *                      via QSPI2 (SLSO15) interface.
; ..\cstart.c	  1932           */
; ..\cstart.c	  1933          QSPI2_BACONENTRY.U = (0x0 |(0x1 << 16) | (0x1 << 21 ) | (0 << 22) | (0x1F << 23) | (0xF << 28));
; ..\cstart.c	  1934  }
; ..\cstart.c	  1935  
; ..\cstart.c	  1936  static void inline qspi2_end_of_frame( void )
; ..\cstart.c	  1937  {
; ..\cstart.c	  1938          QSPI2_BACONENTRY.U = 1; /* Last frame */
; ..\cstart.c	  1939          
; ..\cstart.c	  1940          /*
; ..\cstart.c	  1941           *      When the 32-bit SPI frame contains the value FFFF:FFFFH,
; ..\cstart.c	  1942           *      it indicates that the current frame is the End-of-Frame (EOF).
; ..\cstart.c	  1943           *      This frame will then be ignored by the arbiter state machine.
; ..\cstart.c	  1944           */
; ..\cstart.c	  1945          qspi2_write_word( 0xFFFF, 0xFFFF );
; ..\cstart.c	  1946  }
; ..\cstart.c	  1947  
; ..\cstart.c	  1948  static volatile _Bool __far     qspi2_transmitted;
; ..\cstart.c	  1949  static volatile _Bool __far     qspi2_received;
; ..\cstart.c	  1950  static unsigned int __far       qspi2_rxexit;
; ..\cstart.c	  1951  
; ..\cstart.c	  1952  static void qspi2_send_data( unsigned int data_entry )
; ..\cstart.c	  1953  {
; ..\cstart.c	  1954          qspi2_transmitted = 0;
; ..\cstart.c	  1955  
; ..\cstart.c	  1956          scr_wait();                             /* Wait until XRAM accessible */
; ..\cstart.c	  1957  
; ..\cstart.c	  1958          QSPI2_DATAENTRY0.U = data_entry;        /* Write TX FIFO */
; ..\cstart.c	  1959  
; ..\cstart.c	  1960          while( !qspi2_transmitted );            /* Wait until transmitted */
; ..\cstart.c	  1961  }
; ..\cstart.c	  1962  
; ..\cstart.c	  1963  /*
; ..\cstart.c	  1964   *      qspi2_write_word and qspi2_read_word data_extry:
; ..\cstart.c	  1965   *
; ..\cstart.c	  1966   *      [31]    Read/Write indication:
; ..\cstart.c	  1967   *              - 1 indicates a write access to XRAM.
; ..\cstart.c	  1968   *              - 0 indicates a read access from XRAM.
; ..\cstart.c	  1969   *      [30:29] Control bits:
; ..\cstart.c	  1970   *              - Should be written with 0.
; ..\cstart.c	  1971   *      [28:16] 13-bit XRAM address.
; ..\cstart.c	  1972   *              Note: For smaller XRAM where the address width is
; ..\cstart.c	  1973   *              less than 13 bits, the unused uppermost bits should
; ..\cstart.c	  1974   *              be written with 0.
; ..\cstart.c	  1975   *      [15:0]  16-bit data.
; ..\cstart.c	  1976   */
; ..\cstart.c	  1977  static void qspi2_write_word( unsigned short address, unsigned short data )
; ..\cstart.c	  1978  {
; ..\cstart.c	  1979          unsigned int data_entry = (0x1 << 31) | (address << 16) | data;
; ..\cstart.c	  1980  
; ..\cstart.c	  1981          qspi2_send_data( data_entry );
; ..\cstart.c	  1982  }
; ..\cstart.c	  1983  
; ..\cstart.c	  1984  void __interrupt( QSPI2_INTERRUPT_NR ) qspi2_rxtx( void )
; ..\cstart.c	  1985  {
; ..\cstart.c	  1986          if ( QSPI2_STATUS.B.TXF == 1 )
; ..\cstart.c	  1987          {
; ..\cstart.c	  1988                  /*
; ..\cstart.c	  1989                   *      Transmit Interrupt Request Flag
; ..\cstart.c	  1990                   *      Flags an occurrence of a request to feed the TXFIFO,
; ..\cstart.c	  1991                   *      which is generated when an element is fetched from the
; ..\cstart.c	  1992                   *      FIFO, and the FIFO filling level is equal or less than the
; ..\cstart.c	  1993                   *      set threshold level.
; ..\cstart.c	  1994                   *
; ..\cstart.c	  1995                   *      Transmit Event Flag Clear
; ..\cstart.c	  1996                   *      Write clears the STATUS.TXF bit.
; ..\cstart.c	  1997                   */
; ..\cstart.c	  1998                  QSPI2_FLAGSCLEAR.B.TXC = 1;
; ..\cstart.c	  1999                  QSPI2_STATUS.B.TXF;             /* Read back else TXF not cleared immediate, why? */
; ..\cstart.c	  2000                  qspi2_transmitted = 1;          /* Flag transmitted */
; ..\cstart.c	  2001          }
; ..\cstart.c	  2002          else if ( QSPI2_STATUS.B.RXF == 1 )
; ..\cstart.c	  2003          {
; ..\cstart.c	  2004                  /*
; ..\cstart.c	  2005                   *      Receive Interrupt Request Flag
; ..\cstart.c	  2006                   *      Flags an occurrence of a request to empty the RXFIFO,
; ..\cstart.c	  2007                   *      which is generated when an element is written into the
; ..\cstart.c	  2008                   *      FIFO, and the FIFO filling level is equal or greater than
; ..\cstart.c	  2009                   *      the set threshold level.
; ..\cstart.c	  2010                   *
; ..\cstart.c	  2011                   *      Receive Event Flag Clear
; ..\cstart.c	  2012                   *      Write clears the STATUS.RXF bit.
; ..\cstart.c	  2013                   */
; ..\cstart.c	  2014                  QSPI2_FLAGSCLEAR.B.RXC = 1;
; ..\cstart.c	  2015                  /*
; ..\cstart.c	  2016                   *      RXEXIT - reads from this location deliver either
; ..\cstart.c	  2017                   *      data or data and status, based on a set of rules.
; ..\cstart.c	  2018                   */
; ..\cstart.c	  2019                  qspi2_rxexit = QSPI2_RXEXIT.U;
; ..\cstart.c	  2020                  qspi2_received = 1;             /* Flag received */
; ..\cstart.c	  2021          }
; ..\cstart.c	  2022  }
; ..\cstart.c	  2023  
; ..\cstart.c	  2024  #endif
; ..\cstart.c	  2025  #endif
; ..\cstart.c	  2026  #endif

	; Module end
